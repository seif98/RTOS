
RTOS_LAB1_ATMEGA32.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000195a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000038  00800060  0000195a  000019ee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002eb  00800098  00800098  00001a26  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001a26  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001a58  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000320  00000000  00000000  00001a94  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003d31  00000000  00000000  00001db4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001293  00000000  00000000  00005ae5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001ec6  00000000  00000000  00006d78  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000008f0  00000000  00000000  00008c40  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001102  00000000  00000000  00009530  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002eab  00000000  00000000  0000a632  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002e0  00000000  00000000  0000d4dd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3a 00 	jmp	0x74	; 0x74 <__ctors_end>
       4:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
       8:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
       c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      10:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      14:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      18:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      1c:	0c 94 6a 03 	jmp	0x6d4	; 0x6d4 <__vector_7>
      20:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      24:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      28:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      2c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      30:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      34:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      38:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      3c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      40:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      44:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      48:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      4c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      50:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      54:	f8 00       	.word	0x00f8	; ????
      56:	d8 00       	.word	0x00d8	; ????
      58:	da 00       	.word	0x00da	; ????
      5a:	dc 00       	.word	0x00dc	; ????
      5c:	de 00       	.word	0x00de	; ????
      5e:	e0 00       	.word	0x00e0	; ????
      60:	e2 00       	.word	0x00e2	; ????
      62:	e4 00       	.word	0x00e4	; ????
      64:	e6 00       	.word	0x00e6	; ????
      66:	e8 00       	.word	0x00e8	; ????
      68:	ea 00       	.word	0x00ea	; ????
      6a:	ec 00       	.word	0x00ec	; ????
      6c:	ee 00       	.word	0x00ee	; ????
      6e:	f0 00       	.word	0x00f0	; ????
      70:	f2 00       	.word	0x00f2	; ????
      72:	f4 00       	.word	0x00f4	; ????

00000074 <__ctors_end>:
      74:	11 24       	eor	r1, r1
      76:	1f be       	out	0x3f, r1	; 63
      78:	cf e5       	ldi	r28, 0x5F	; 95
      7a:	d8 e0       	ldi	r29, 0x08	; 8
      7c:	de bf       	out	0x3e, r29	; 62
      7e:	cd bf       	out	0x3d, r28	; 61

00000080 <__do_copy_data>:
      80:	10 e0       	ldi	r17, 0x00	; 0
      82:	a0 e6       	ldi	r26, 0x60	; 96
      84:	b0 e0       	ldi	r27, 0x00	; 0
      86:	ea e5       	ldi	r30, 0x5A	; 90
      88:	f9 e1       	ldi	r31, 0x19	; 25
      8a:	02 c0       	rjmp	.+4      	; 0x90 <__do_copy_data+0x10>
      8c:	05 90       	lpm	r0, Z+
      8e:	0d 92       	st	X+, r0
      90:	a8 39       	cpi	r26, 0x98	; 152
      92:	b1 07       	cpc	r27, r17
      94:	d9 f7       	brne	.-10     	; 0x8c <__do_copy_data+0xc>

00000096 <__do_clear_bss>:
      96:	23 e0       	ldi	r18, 0x03	; 3
      98:	a8 e9       	ldi	r26, 0x98	; 152
      9a:	b0 e0       	ldi	r27, 0x00	; 0
      9c:	01 c0       	rjmp	.+2      	; 0xa0 <.do_clear_bss_start>

0000009e <.do_clear_bss_loop>:
      9e:	1d 92       	st	X+, r1

000000a0 <.do_clear_bss_start>:
      a0:	a3 38       	cpi	r26, 0x83	; 131
      a2:	b2 07       	cpc	r27, r18
      a4:	e1 f7       	brne	.-8      	; 0x9e <.do_clear_bss_loop>
      a6:	0e 94 79 05 	call	0xaf2	; 0xaf2 <main>
      aa:	0c 94 ab 0c 	jmp	0x1956	; 0x1956 <_exit>

000000ae <__bad_interrupt>:
      ae:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b2 <DIO_voidSetPort>:
      b2:	81 11       	cpse	r24, r1
      b4:	02 c0       	rjmp	.+4      	; 0xba <DIO_voidSetPort+0x8>
      b6:	6b bb       	out	0x1b, r22	; 27
      b8:	08 95       	ret
      ba:	81 30       	cpi	r24, 0x01	; 1
      bc:	11 f4       	brne	.+4      	; 0xc2 <DIO_voidSetPort+0x10>
      be:	68 bb       	out	0x18, r22	; 24
      c0:	08 95       	ret
      c2:	82 30       	cpi	r24, 0x02	; 2
      c4:	11 f4       	brne	.+4      	; 0xca <DIO_voidSetPort+0x18>
      c6:	65 bb       	out	0x15, r22	; 21
      c8:	08 95       	ret
      ca:	83 30       	cpi	r24, 0x03	; 3
      cc:	09 f4       	brne	.+2      	; 0xd0 <DIO_voidSetPort+0x1e>
      ce:	62 bb       	out	0x12, r22	; 18
      d0:	08 95       	ret

000000d2 <DIO_voidSetPortDir>:
      d2:	81 11       	cpse	r24, r1
      d4:	02 c0       	rjmp	.+4      	; 0xda <DIO_voidSetPortDir+0x8>
      d6:	6a bb       	out	0x1a, r22	; 26
      d8:	08 95       	ret
      da:	81 30       	cpi	r24, 0x01	; 1
      dc:	11 f4       	brne	.+4      	; 0xe2 <DIO_voidSetPortDir+0x10>
      de:	67 bb       	out	0x17, r22	; 23
      e0:	08 95       	ret
      e2:	82 30       	cpi	r24, 0x02	; 2
      e4:	11 f4       	brne	.+4      	; 0xea <DIO_voidSetPortDir+0x18>
      e6:	64 bb       	out	0x14, r22	; 20
      e8:	08 95       	ret
      ea:	83 30       	cpi	r24, 0x03	; 3
      ec:	09 f4       	brne	.+2      	; 0xf0 <DIO_voidSetPortDir+0x1e>
      ee:	61 bb       	out	0x11, r22	; 17
      f0:	08 95       	ret

000000f2 <DIO_u8GetPinInPort>:
      f2:	81 11       	cpse	r24, r1
      f4:	09 c0       	rjmp	.+18     	; 0x108 <DIO_u8GetPinInPort+0x16>
      f6:	89 b3       	in	r24, 0x19	; 25
      f8:	90 e0       	ldi	r25, 0x00	; 0
      fa:	02 c0       	rjmp	.+4      	; 0x100 <DIO_u8GetPinInPort+0xe>
      fc:	95 95       	asr	r25
      fe:	87 95       	ror	r24
     100:	6a 95       	dec	r22
     102:	e2 f7       	brpl	.-8      	; 0xfc <DIO_u8GetPinInPort+0xa>
     104:	81 70       	andi	r24, 0x01	; 1
     106:	08 95       	ret
     108:	81 30       	cpi	r24, 0x01	; 1
     10a:	49 f4       	brne	.+18     	; 0x11e <DIO_u8GetPinInPort+0x2c>
     10c:	86 b3       	in	r24, 0x16	; 22
     10e:	90 e0       	ldi	r25, 0x00	; 0
     110:	02 c0       	rjmp	.+4      	; 0x116 <DIO_u8GetPinInPort+0x24>
     112:	95 95       	asr	r25
     114:	87 95       	ror	r24
     116:	6a 95       	dec	r22
     118:	e2 f7       	brpl	.-8      	; 0x112 <DIO_u8GetPinInPort+0x20>
     11a:	81 70       	andi	r24, 0x01	; 1
     11c:	08 95       	ret
     11e:	82 30       	cpi	r24, 0x02	; 2
     120:	49 f4       	brne	.+18     	; 0x134 <DIO_u8GetPinInPort+0x42>
     122:	83 b3       	in	r24, 0x13	; 19
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	02 c0       	rjmp	.+4      	; 0x12c <DIO_u8GetPinInPort+0x3a>
     128:	95 95       	asr	r25
     12a:	87 95       	ror	r24
     12c:	6a 95       	dec	r22
     12e:	e2 f7       	brpl	.-8      	; 0x128 <DIO_u8GetPinInPort+0x36>
     130:	81 70       	andi	r24, 0x01	; 1
     132:	08 95       	ret
     134:	83 30       	cpi	r24, 0x03	; 3
     136:	49 f4       	brne	.+18     	; 0x14a <DIO_u8GetPinInPort+0x58>
     138:	80 b3       	in	r24, 0x10	; 16
     13a:	90 e0       	ldi	r25, 0x00	; 0
     13c:	02 c0       	rjmp	.+4      	; 0x142 <DIO_u8GetPinInPort+0x50>
     13e:	95 95       	asr	r25
     140:	87 95       	ror	r24
     142:	6a 95       	dec	r22
     144:	e2 f7       	brpl	.-8      	; 0x13e <DIO_u8GetPinInPort+0x4c>
     146:	81 70       	andi	r24, 0x01	; 1
     148:	08 95       	ret
     14a:	80 e0       	ldi	r24, 0x00	; 0
     14c:	08 95       	ret

0000014e <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     14e:	cf 93       	push	r28
     150:	df 93       	push	r29
     152:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     154:	0e 94 2f 09 	call	0x125e	; 0x125e <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     158:	20 91 98 00 	lds	r18, 0x0098	; 0x800098 <__data_end>
     15c:	30 91 99 00 	lds	r19, 0x0099	; 0x800099 <__data_end+0x1>
     160:	c9 01       	movw	r24, r18
     162:	8c 0f       	add	r24, r28
     164:	9d 1f       	adc	r25, r29
     166:	88 35       	cpi	r24, 0x58	; 88
     168:	42 e0       	ldi	r20, 0x02	; 2
     16a:	94 07       	cpc	r25, r20
     16c:	58 f4       	brcc	.+22     	; 0x184 <pvPortMalloc+0x36>
     16e:	28 17       	cp	r18, r24
     170:	39 07       	cpc	r19, r25
     172:	58 f4       	brcc	.+22     	; 0x18a <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     174:	e9 01       	movw	r28, r18
     176:	c6 56       	subi	r28, 0x66	; 102
     178:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     17a:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__data_end+0x1>
     17e:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__data_end>
     182:	05 c0       	rjmp	.+10     	; 0x18e <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     184:	c0 e0       	ldi	r28, 0x00	; 0
     186:	d0 e0       	ldi	r29, 0x00	; 0
     188:	02 c0       	rjmp	.+4      	; 0x18e <pvPortMalloc+0x40>
     18a:	c0 e0       	ldi	r28, 0x00	; 0
     18c:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     18e:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     192:	ce 01       	movw	r24, r28
     194:	df 91       	pop	r29
     196:	cf 91       	pop	r28
     198:	08 95       	ret

0000019a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     19a:	08 95       	ret

0000019c <KeyPad_u8AdjustKeyNumber>:

}
#elif KEYPAD_ORIENTATION == FOURxFOUR
unsigned char KeyPad_u8AdjustKeyNumber(u8 button_number)
{
    switch(button_number)
     19c:	90 e0       	ldi	r25, 0x00	; 0
     19e:	fc 01       	movw	r30, r24
     1a0:	31 97       	sbiw	r30, 0x01	; 1
     1a2:	e0 31       	cpi	r30, 0x10	; 16
     1a4:	f1 05       	cpc	r31, r1
     1a6:	10 f5       	brcc	.+68     	; 0x1ec <KeyPad_u8AdjustKeyNumber+0x50>
     1a8:	e6 5d       	subi	r30, 0xD6	; 214
     1aa:	ff 4f       	sbci	r31, 0xFF	; 255
     1ac:	0c 94 4c 0c 	jmp	0x1898	; 0x1898 <__tablejump2__>
	{
		case 1: return '7';
				break;
		case 2: return '8';
     1b0:	88 e3       	ldi	r24, 0x38	; 56
     1b2:	08 95       	ret
				break;
		case 3: return '9';
     1b4:	89 e3       	ldi	r24, 0x39	; 57
     1b6:	08 95       	ret
				break;
		case 4: return '÷'; 
     1b8:	87 ef       	ldi	r24, 0xF7	; 247
     1ba:	08 95       	ret
				break;
		case 5: return '4';
     1bc:	84 e3       	ldi	r24, 0x34	; 52
     1be:	08 95       	ret
				break;
		case 6: return '5';
     1c0:	85 e3       	ldi	r24, 0x35	; 53
     1c2:	08 95       	ret
				break;
		case 7: return '6';
     1c4:	86 e3       	ldi	r24, 0x36	; 54
     1c6:	08 95       	ret
				break;
		case 8: return 'X'; 
     1c8:	88 e5       	ldi	r24, 0x58	; 88
     1ca:	08 95       	ret
				break;
		case 9: return '1';
     1cc:	81 e3       	ldi	r24, 0x31	; 49
     1ce:	08 95       	ret
				break;
		case 10: return '2';
     1d0:	82 e3       	ldi	r24, 0x32	; 50
     1d2:	08 95       	ret
				break;
		case 11: return '3';
     1d4:	83 e3       	ldi	r24, 0x33	; 51
     1d6:	08 95       	ret
				break;
		case 12: return '-'; 
     1d8:	8d e2       	ldi	r24, 0x2D	; 45
     1da:	08 95       	ret
				break;
		case 13: return 'C';  
     1dc:	83 e4       	ldi	r24, 0x43	; 67
     1de:	08 95       	ret
				break;
		case 14: return '0';
     1e0:	80 e3       	ldi	r24, 0x30	; 48
     1e2:	08 95       	ret
				break;
		case 15: return '='; 
     1e4:	8d e3       	ldi	r24, 0x3D	; 61
     1e6:	08 95       	ret
				break;
		case 16: return '+'; 
     1e8:	8b e2       	ldi	r24, 0x2B	; 43
     1ea:	08 95       	ret
				break;
		default: return NO_KEY_PRESSED;
     1ec:	8f ef       	ldi	r24, 0xFF	; 255
     1ee:	08 95       	ret
#elif KEYPAD_ORIENTATION == FOURxFOUR
unsigned char KeyPad_u8AdjustKeyNumber(u8 button_number)
{
    switch(button_number)
	{
		case 1: return '7';
     1f0:	87 e3       	ldi	r24, 0x37	; 55
		case 16: return '+'; 
				break;
		default: return NO_KEY_PRESSED;
	}

}
     1f2:	08 95       	ret

000001f4 <KeyPad_u8GetPressedKey>:
#include "KeyPad.h"


/***  checks for the number of the  button pressed  ***/
unsigned char KeyPad_u8GetPressedKey(void)
{
     1f4:	bf 92       	push	r11
     1f6:	cf 92       	push	r12
     1f8:	df 92       	push	r13
     1fa:	ef 92       	push	r14
     1fc:	ff 92       	push	r15
     1fe:	0f 93       	push	r16
     200:	1f 93       	push	r17
     202:	cf 93       	push	r28
     204:	df 93       	push	r29
    unsigned char col,row,i=0;
     206:	10 e0       	ldi	r17, 0x00	; 0
			/*
				* Each time only one of the column pins will be output and
			* the rest will be input pins including the row pins
			*/

			DIO_voidSetPortDir(KEYPAD_PORT, (0b00010000 << col));
     208:	68 94       	set
     20a:	cc 24       	eor	r12, r12
     20c:	c4 f8       	bld	r12, 4
     20e:	d1 2c       	mov	r13, r1
     210:	33 c0       	rjmp	.+102    	; 0x278 <KeyPad_u8GetPressedKey+0x84>
     212:	be 2c       	mov	r11, r14
     214:	e6 01       	movw	r28, r12
     216:	0e 2c       	mov	r0, r14
     218:	02 c0       	rjmp	.+4      	; 0x21e <KeyPad_u8GetPressedKey+0x2a>
     21a:	cc 0f       	add	r28, r28
     21c:	dd 1f       	adc	r29, r29
     21e:	0a 94       	dec	r0
     220:	e2 f7       	brpl	.-8      	; 0x21a <KeyPad_u8GetPressedKey+0x26>
     222:	6c 2f       	mov	r22, r28
     224:	82 e0       	ldi	r24, 0x02	; 2
     226:	0e 94 69 00 	call	0xd2	; 0xd2 <DIO_voidSetPortDir>
			/*
			* clear the output pin column and enable the internal
			* pull up resistors for the other pins
			*/
			
			DIO_voidSetPort(KEYPAD_PORT, (~(0b00010000 << col)));
     22a:	6c 2f       	mov	r22, r28
     22c:	60 95       	com	r22
     22e:	82 e0       	ldi	r24, 0x02	; 2
     230:	0e 94 59 00 	call	0xb2	; 0xb2 <DIO_voidSetPort>
     234:	c0 e0       	ldi	r28, 0x00	; 0
     236:	d0 e0       	ldi	r29, 0x00	; 0
     238:	0c 2f       	mov	r16, r28
			for(row=0; row<N_row; row++) /* loop for rows */
			{
				if(DIO_u8GetPinInPort(KEYPAD_PORT, row) == DIO_LOW) /* if the switch is pressed in this row */
     23a:	be 01       	movw	r22, r28
     23c:	82 e0       	ldi	r24, 0x02	; 2
     23e:	90 e0       	ldi	r25, 0x00	; 0
     240:	0e 94 79 00 	call	0xf2	; 0xf2 <DIO_u8GetPinInPort>
     244:	89 2b       	or	r24, r25
     246:	59 f4       	brne	.+22     	; 0x25e <KeyPad_u8GetPressedKey+0x6a>
				{
					i++;
     248:	1f 5f       	subi	r17, 0xFF	; 255
					if(i > 200)
     24a:	19 3c       	cpi	r17, 0xC9	; 201
     24c:	40 f0       	brcs	.+16     	; 0x25e <KeyPad_u8GetPressedKey+0x6a>
					{
						return KeyPad_u8AdjustKeyNumber((row*N_col)+col+1);
     24e:	00 0f       	add	r16, r16
     250:	00 0f       	add	r16, r16
     252:	81 e0       	ldi	r24, 0x01	; 1
     254:	8b 0d       	add	r24, r11
     256:	80 0f       	add	r24, r16
     258:	0e 94 ce 00 	call	0x19c	; 0x19c <KeyPad_u8AdjustKeyNumber>
     25c:	11 c0       	rjmp	.+34     	; 0x280 <KeyPad_u8GetPressedKey+0x8c>
     25e:	21 96       	adiw	r28, 0x01	; 1
			* clear the output pin column and enable the internal
			* pull up resistors for the other pins
			*/
			
			DIO_voidSetPort(KEYPAD_PORT, (~(0b00010000 << col)));
			for(row=0; row<N_row; row++) /* loop for rows */
     260:	c4 30       	cpi	r28, 0x04	; 4
     262:	d1 05       	cpc	r29, r1
     264:	49 f7       	brne	.-46     	; 0x238 <KeyPad_u8GetPressedKey+0x44>
     266:	8f ef       	ldi	r24, 0xFF	; 255
     268:	e8 1a       	sub	r14, r24
     26a:	f8 0a       	sbc	r15, r24
unsigned char KeyPad_u8GetPressedKey(void)
{
    unsigned char col,row,i=0;
	while(i < 210)
	{
		for(col=0; col < N_col; col++) /* loop for columns */
     26c:	84 e0       	ldi	r24, 0x04	; 4
     26e:	e8 16       	cp	r14, r24
     270:	f1 04       	cpc	r15, r1
     272:	79 f6       	brne	.-98     	; 0x212 <KeyPad_u8GetPressedKey+0x1e>

/***  checks for the number of the  button pressed  ***/
unsigned char KeyPad_u8GetPressedKey(void)
{
    unsigned char col,row,i=0;
	while(i < 210)
     274:	12 3d       	cpi	r17, 0xD2	; 210
     276:	18 f4       	brcc	.+6      	; 0x27e <KeyPad_u8GetPressedKey+0x8a>
#include "KeyPad.h"


/***  checks for the number of the  button pressed  ***/
unsigned char KeyPad_u8GetPressedKey(void)
{
     278:	e1 2c       	mov	r14, r1
     27a:	f1 2c       	mov	r15, r1
     27c:	ca cf       	rjmp	.-108    	; 0x212 <KeyPad_u8GetPressedKey+0x1e>
				}
			}
		}
	}

    return NO_KEY_PRESSED;
     27e:	8f ef       	ldi	r24, 0xFF	; 255
}
     280:	df 91       	pop	r29
     282:	cf 91       	pop	r28
     284:	1f 91       	pop	r17
     286:	0f 91       	pop	r16
     288:	ff 90       	pop	r15
     28a:	ef 90       	pop	r14
     28c:	df 90       	pop	r13
     28e:	cf 90       	pop	r12
     290:	bf 90       	pop	r11
     292:	08 95       	ret

00000294 <enableTrigger>:
     294:	c2 98       	cbi	0x18, 2	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     296:	89 ef       	ldi	r24, 0xF9	; 249
     298:	90 e0       	ldi	r25, 0x00	; 0
     29a:	01 97       	sbiw	r24, 0x01	; 1
     29c:	f1 f7       	brne	.-4      	; 0x29a <enableTrigger+0x6>
     29e:	00 c0       	rjmp	.+0      	; 0x2a0 <enableTrigger+0xc>
     2a0:	00 00       	nop
     2a2:	c2 9a       	sbi	0x18, 2	; 24
     2a4:	8b ed       	ldi	r24, 0xDB	; 219
     2a6:	95 e0       	ldi	r25, 0x05	; 5
     2a8:	01 97       	sbiw	r24, 0x01	; 1
     2aa:	f1 f7       	brne	.-4      	; 0x2a8 <enableTrigger+0x14>
     2ac:	00 c0       	rjmp	.+0      	; 0x2ae <enableTrigger+0x1a>
     2ae:	00 00       	nop
     2b0:	08 95       	ret

000002b2 <lcd_sendCommand>:
     2b2:	cf 93       	push	r28
     2b4:	c8 2f       	mov	r28, r24
     2b6:	c0 98       	cbi	0x18, 0	; 24
     2b8:	c1 98       	cbi	0x18, 1	; 24
     2ba:	88 b3       	in	r24, 0x18	; 24
     2bc:	8f 70       	andi	r24, 0x0F	; 15
     2be:	88 bb       	out	0x18, r24	; 24
     2c0:	88 b3       	in	r24, 0x18	; 24
     2c2:	9c 2f       	mov	r25, r28
     2c4:	90 7f       	andi	r25, 0xF0	; 240
     2c6:	89 2b       	or	r24, r25
     2c8:	88 bb       	out	0x18, r24	; 24
     2ca:	0e 94 4a 01 	call	0x294	; 0x294 <enableTrigger>
     2ce:	88 b3       	in	r24, 0x18	; 24
     2d0:	8f 70       	andi	r24, 0x0F	; 15
     2d2:	88 bb       	out	0x18, r24	; 24
     2d4:	88 b3       	in	r24, 0x18	; 24
     2d6:	c2 95       	swap	r28
     2d8:	c0 7f       	andi	r28, 0xF0	; 240
     2da:	c8 2b       	or	r28, r24
     2dc:	c8 bb       	out	0x18, r28	; 24
     2de:	0e 94 4a 01 	call	0x294	; 0x294 <enableTrigger>
     2e2:	cf 91       	pop	r28
     2e4:	08 95       	ret

000002e6 <lcd_init>:
     2e6:	8f ef       	ldi	r24, 0xFF	; 255
     2e8:	87 bb       	out	0x17, r24	; 23
     2ea:	84 e0       	ldi	r24, 0x04	; 4
     2ec:	88 bb       	out	0x18, r24	; 24
     2ee:	83 e3       	ldi	r24, 0x33	; 51
     2f0:	0e 94 59 01 	call	0x2b2	; 0x2b2 <lcd_sendCommand>
     2f4:	82 e3       	ldi	r24, 0x32	; 50
     2f6:	0e 94 59 01 	call	0x2b2	; 0x2b2 <lcd_sendCommand>
     2fa:	88 e2       	ldi	r24, 0x28	; 40
     2fc:	0e 94 59 01 	call	0x2b2	; 0x2b2 <lcd_sendCommand>
     300:	8c e0       	ldi	r24, 0x0C	; 12
     302:	0e 94 59 01 	call	0x2b2	; 0x2b2 <lcd_sendCommand>
     306:	08 95       	ret

00000308 <lcd_displayChar>:
     308:	cf 93       	push	r28
     30a:	c8 2f       	mov	r28, r24
     30c:	c0 9a       	sbi	0x18, 0	; 24
     30e:	c1 98       	cbi	0x18, 1	; 24
     310:	88 b3       	in	r24, 0x18	; 24
     312:	8f 70       	andi	r24, 0x0F	; 15
     314:	88 bb       	out	0x18, r24	; 24
     316:	88 b3       	in	r24, 0x18	; 24
     318:	9c 2f       	mov	r25, r28
     31a:	90 7f       	andi	r25, 0xF0	; 240
     31c:	89 2b       	or	r24, r25
     31e:	88 bb       	out	0x18, r24	; 24
     320:	0e 94 4a 01 	call	0x294	; 0x294 <enableTrigger>
     324:	88 b3       	in	r24, 0x18	; 24
     326:	8f 70       	andi	r24, 0x0F	; 15
     328:	88 bb       	out	0x18, r24	; 24
     32a:	88 b3       	in	r24, 0x18	; 24
     32c:	c2 95       	swap	r28
     32e:	c0 7f       	andi	r28, 0xF0	; 240
     330:	c8 2b       	or	r28, r24
     332:	c8 bb       	out	0x18, r28	; 24
     334:	0e 94 4a 01 	call	0x294	; 0x294 <enableTrigger>
     338:	cf 91       	pop	r28
     33a:	08 95       	ret

0000033c <lcd_gotoxy>:
     33c:	81 30       	cpi	r24, 0x01	; 1
     33e:	49 f0       	breq	.+18     	; 0x352 <lcd_gotoxy+0x16>
     340:	28 f0       	brcs	.+10     	; 0x34c <lcd_gotoxy+0x10>
     342:	82 30       	cpi	r24, 0x02	; 2
     344:	49 f0       	breq	.+18     	; 0x358 <lcd_gotoxy+0x1c>
     346:	83 30       	cpi	r24, 0x03	; 3
     348:	51 f0       	breq	.+20     	; 0x35e <lcd_gotoxy+0x22>
     34a:	0c c0       	rjmp	.+24     	; 0x364 <lcd_gotoxy+0x28>
     34c:	80 e8       	ldi	r24, 0x80	; 128
     34e:	86 0f       	add	r24, r22
     350:	0a c0       	rjmp	.+20     	; 0x366 <lcd_gotoxy+0x2a>
     352:	80 ec       	ldi	r24, 0xC0	; 192
     354:	86 0f       	add	r24, r22
     356:	07 c0       	rjmp	.+14     	; 0x366 <lcd_gotoxy+0x2a>
     358:	80 e8       	ldi	r24, 0x80	; 128
     35a:	86 0f       	add	r24, r22
     35c:	04 c0       	rjmp	.+8      	; 0x366 <lcd_gotoxy+0x2a>
     35e:	80 e8       	ldi	r24, 0x80	; 128
     360:	86 0f       	add	r24, r22
     362:	01 c0       	rjmp	.+2      	; 0x366 <lcd_gotoxy+0x2a>
     364:	80 e8       	ldi	r24, 0x80	; 128
     366:	0e 94 59 01 	call	0x2b2	; 0x2b2 <lcd_sendCommand>
     36a:	08 95       	ret

0000036c <lcd_clrScreen>:
     36c:	81 e0       	ldi	r24, 0x01	; 1
     36e:	0e 94 59 01 	call	0x2b2	; 0x2b2 <lcd_sendCommand>
     372:	08 95       	ret

00000374 <lcd_dispString>:
     374:	cf 93       	push	r28
     376:	df 93       	push	r29
     378:	ec 01       	movw	r28, r24
     37a:	88 81       	ld	r24, Y
     37c:	88 23       	and	r24, r24
     37e:	31 f0       	breq	.+12     	; 0x38c <lcd_dispString+0x18>
     380:	21 96       	adiw	r28, 0x01	; 1
     382:	0e 94 84 01 	call	0x308	; 0x308 <lcd_displayChar>
     386:	89 91       	ld	r24, Y+
     388:	81 11       	cpse	r24, r1
     38a:	fb cf       	rjmp	.-10     	; 0x382 <lcd_dispString+0xe>
     38c:	df 91       	pop	r29
     38e:	cf 91       	pop	r28
     390:	08 95       	ret

00000392 <lcd_disp_string_xy>:
     392:	cf 93       	push	r28
     394:	df 93       	push	r29
     396:	ec 01       	movw	r28, r24
     398:	86 2f       	mov	r24, r22
     39a:	64 2f       	mov	r22, r20
     39c:	0e 94 9e 01 	call	0x33c	; 0x33c <lcd_gotoxy>
     3a0:	ce 01       	movw	r24, r28
     3a2:	0e 94 ba 01 	call	0x374	; 0x374 <lcd_dispString>
     3a6:	df 91       	pop	r29
     3a8:	cf 91       	pop	r28
     3aa:	08 95       	ret

000003ac <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     3ac:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     3ae:	03 96       	adiw	r24, 0x03	; 3
     3b0:	92 83       	std	Z+2, r25	; 0x02
     3b2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     3b4:	2f ef       	ldi	r18, 0xFF	; 255
     3b6:	3f ef       	ldi	r19, 0xFF	; 255
     3b8:	34 83       	std	Z+4, r19	; 0x04
     3ba:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     3bc:	96 83       	std	Z+6, r25	; 0x06
     3be:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     3c0:	90 87       	std	Z+8, r25	; 0x08
     3c2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     3c4:	10 82       	st	Z, r1
     3c6:	08 95       	ret

000003c8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     3c8:	fc 01       	movw	r30, r24
     3ca:	11 86       	std	Z+9, r1	; 0x09
     3cc:	10 86       	std	Z+8, r1	; 0x08
     3ce:	08 95       	ret

000003d0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     3d0:	cf 93       	push	r28
     3d2:	df 93       	push	r29
     3d4:	fc 01       	movw	r30, r24
     3d6:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     3d8:	21 81       	ldd	r18, Z+1	; 0x01
     3da:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     3dc:	e9 01       	movw	r28, r18
     3de:	8a 81       	ldd	r24, Y+2	; 0x02
     3e0:	9b 81       	ldd	r25, Y+3	; 0x03
     3e2:	13 96       	adiw	r26, 0x03	; 3
     3e4:	9c 93       	st	X, r25
     3e6:	8e 93       	st	-X, r24
     3e8:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     3ea:	81 81       	ldd	r24, Z+1	; 0x01
     3ec:	92 81       	ldd	r25, Z+2	; 0x02
     3ee:	15 96       	adiw	r26, 0x05	; 5
     3f0:	9c 93       	st	X, r25
     3f2:	8e 93       	st	-X, r24
     3f4:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     3f6:	8a 81       	ldd	r24, Y+2	; 0x02
     3f8:	9b 81       	ldd	r25, Y+3	; 0x03
     3fa:	ec 01       	movw	r28, r24
     3fc:	7d 83       	std	Y+5, r23	; 0x05
     3fe:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     400:	e9 01       	movw	r28, r18
     402:	7b 83       	std	Y+3, r23	; 0x03
     404:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     406:	72 83       	std	Z+2, r23	; 0x02
     408:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     40a:	19 96       	adiw	r26, 0x09	; 9
     40c:	fc 93       	st	X, r31
     40e:	ee 93       	st	-X, r30
     410:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     412:	80 81       	ld	r24, Z
     414:	8f 5f       	subi	r24, 0xFF	; 255
     416:	80 83       	st	Z, r24
}
     418:	df 91       	pop	r29
     41a:	cf 91       	pop	r28
     41c:	08 95       	ret

0000041e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     41e:	cf 93       	push	r28
     420:	df 93       	push	r29
     422:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     424:	48 81       	ld	r20, Y
     426:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     428:	4f 3f       	cpi	r20, 0xFF	; 255
     42a:	2f ef       	ldi	r18, 0xFF	; 255
     42c:	52 07       	cpc	r21, r18
     42e:	31 f4       	brne	.+12     	; 0x43c <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     430:	dc 01       	movw	r26, r24
     432:	17 96       	adiw	r26, 0x07	; 7
     434:	ed 91       	ld	r30, X+
     436:	fc 91       	ld	r31, X
     438:	18 97       	sbiw	r26, 0x08	; 8
     43a:	17 c0       	rjmp	.+46     	; 0x46a <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     43c:	fc 01       	movw	r30, r24
     43e:	33 96       	adiw	r30, 0x03	; 3
     440:	dc 01       	movw	r26, r24
     442:	15 96       	adiw	r26, 0x05	; 5
     444:	2d 91       	ld	r18, X+
     446:	3c 91       	ld	r19, X
     448:	16 97       	sbiw	r26, 0x06	; 6
     44a:	d9 01       	movw	r26, r18
     44c:	2d 91       	ld	r18, X+
     44e:	3c 91       	ld	r19, X
     450:	42 17       	cp	r20, r18
     452:	53 07       	cpc	r21, r19
     454:	50 f0       	brcs	.+20     	; 0x46a <vListInsert+0x4c>
     456:	02 80       	ldd	r0, Z+2	; 0x02
     458:	f3 81       	ldd	r31, Z+3	; 0x03
     45a:	e0 2d       	mov	r30, r0
     45c:	a2 81       	ldd	r26, Z+2	; 0x02
     45e:	b3 81       	ldd	r27, Z+3	; 0x03
     460:	2d 91       	ld	r18, X+
     462:	3c 91       	ld	r19, X
     464:	42 17       	cp	r20, r18
     466:	53 07       	cpc	r21, r19
     468:	b0 f7       	brcc	.-20     	; 0x456 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     46a:	a2 81       	ldd	r26, Z+2	; 0x02
     46c:	b3 81       	ldd	r27, Z+3	; 0x03
     46e:	bb 83       	std	Y+3, r27	; 0x03
     470:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     472:	15 96       	adiw	r26, 0x05	; 5
     474:	dc 93       	st	X, r29
     476:	ce 93       	st	-X, r28
     478:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     47a:	fd 83       	std	Y+5, r31	; 0x05
     47c:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     47e:	d3 83       	std	Z+3, r29	; 0x03
     480:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     482:	99 87       	std	Y+9, r25	; 0x09
     484:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     486:	fc 01       	movw	r30, r24
     488:	20 81       	ld	r18, Z
     48a:	2f 5f       	subi	r18, 0xFF	; 255
     48c:	20 83       	st	Z, r18
}
     48e:	df 91       	pop	r29
     490:	cf 91       	pop	r28
     492:	08 95       	ret

00000494 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     494:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     496:	a2 81       	ldd	r26, Z+2	; 0x02
     498:	b3 81       	ldd	r27, Z+3	; 0x03
     49a:	84 81       	ldd	r24, Z+4	; 0x04
     49c:	95 81       	ldd	r25, Z+5	; 0x05
     49e:	15 96       	adiw	r26, 0x05	; 5
     4a0:	9c 93       	st	X, r25
     4a2:	8e 93       	st	-X, r24
     4a4:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4a6:	a4 81       	ldd	r26, Z+4	; 0x04
     4a8:	b5 81       	ldd	r27, Z+5	; 0x05
     4aa:	82 81       	ldd	r24, Z+2	; 0x02
     4ac:	93 81       	ldd	r25, Z+3	; 0x03
     4ae:	13 96       	adiw	r26, 0x03	; 3
     4b0:	9c 93       	st	X, r25
     4b2:	8e 93       	st	-X, r24
     4b4:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     4b6:	a0 85       	ldd	r26, Z+8	; 0x08
     4b8:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     4ba:	11 96       	adiw	r26, 0x01	; 1
     4bc:	8d 91       	ld	r24, X+
     4be:	9c 91       	ld	r25, X
     4c0:	12 97       	sbiw	r26, 0x02	; 2
     4c2:	e8 17       	cp	r30, r24
     4c4:	f9 07       	cpc	r31, r25
     4c6:	31 f4       	brne	.+12     	; 0x4d4 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     4c8:	84 81       	ldd	r24, Z+4	; 0x04
     4ca:	95 81       	ldd	r25, Z+5	; 0x05
     4cc:	12 96       	adiw	r26, 0x02	; 2
     4ce:	9c 93       	st	X, r25
     4d0:	8e 93       	st	-X, r24
     4d2:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     4d4:	11 86       	std	Z+9, r1	; 0x09
     4d6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     4d8:	8c 91       	ld	r24, X
     4da:	81 50       	subi	r24, 0x01	; 1
     4dc:	8c 93       	st	X, r24
     4de:	08 95       	ret

000004e0 <pxPortInitialiseStack>:
	portSAVE_CONTEXT();
	vTaskIncrementTick();
	vTaskSwitchContext();
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
     4e0:	31 e1       	ldi	r19, 0x11	; 17
     4e2:	fc 01       	movw	r30, r24
     4e4:	30 83       	st	Z, r19
     4e6:	31 97       	sbiw	r30, 0x01	; 1
     4e8:	22 e2       	ldi	r18, 0x22	; 34
     4ea:	20 83       	st	Z, r18
     4ec:	31 97       	sbiw	r30, 0x01	; 1
     4ee:	a3 e3       	ldi	r26, 0x33	; 51
     4f0:	a0 83       	st	Z, r26
     4f2:	31 97       	sbiw	r30, 0x01	; 1
     4f4:	60 83       	st	Z, r22
     4f6:	31 97       	sbiw	r30, 0x01	; 1
     4f8:	70 83       	st	Z, r23
     4fa:	31 97       	sbiw	r30, 0x01	; 1
     4fc:	10 82       	st	Z, r1
     4fe:	31 97       	sbiw	r30, 0x01	; 1
     500:	60 e8       	ldi	r22, 0x80	; 128
     502:	60 83       	st	Z, r22
     504:	31 97       	sbiw	r30, 0x01	; 1
     506:	10 82       	st	Z, r1
     508:	31 97       	sbiw	r30, 0x01	; 1
     50a:	62 e0       	ldi	r22, 0x02	; 2
     50c:	60 83       	st	Z, r22
     50e:	31 97       	sbiw	r30, 0x01	; 1
     510:	63 e0       	ldi	r22, 0x03	; 3
     512:	60 83       	st	Z, r22
     514:	31 97       	sbiw	r30, 0x01	; 1
     516:	64 e0       	ldi	r22, 0x04	; 4
     518:	60 83       	st	Z, r22
     51a:	31 97       	sbiw	r30, 0x01	; 1
     51c:	65 e0       	ldi	r22, 0x05	; 5
     51e:	60 83       	st	Z, r22
     520:	31 97       	sbiw	r30, 0x01	; 1
     522:	66 e0       	ldi	r22, 0x06	; 6
     524:	60 83       	st	Z, r22
     526:	31 97       	sbiw	r30, 0x01	; 1
     528:	67 e0       	ldi	r22, 0x07	; 7
     52a:	60 83       	st	Z, r22
     52c:	31 97       	sbiw	r30, 0x01	; 1
     52e:	68 e0       	ldi	r22, 0x08	; 8
     530:	60 83       	st	Z, r22
     532:	31 97       	sbiw	r30, 0x01	; 1
     534:	69 e0       	ldi	r22, 0x09	; 9
     536:	60 83       	st	Z, r22
     538:	31 97       	sbiw	r30, 0x01	; 1
     53a:	60 e1       	ldi	r22, 0x10	; 16
     53c:	60 83       	st	Z, r22
     53e:	31 97       	sbiw	r30, 0x01	; 1
     540:	30 83       	st	Z, r19
     542:	31 97       	sbiw	r30, 0x01	; 1
     544:	32 e1       	ldi	r19, 0x12	; 18
     546:	30 83       	st	Z, r19
     548:	31 97       	sbiw	r30, 0x01	; 1
     54a:	33 e1       	ldi	r19, 0x13	; 19
     54c:	30 83       	st	Z, r19
     54e:	31 97       	sbiw	r30, 0x01	; 1
     550:	34 e1       	ldi	r19, 0x14	; 20
     552:	30 83       	st	Z, r19
     554:	31 97       	sbiw	r30, 0x01	; 1
     556:	35 e1       	ldi	r19, 0x15	; 21
     558:	30 83       	st	Z, r19
     55a:	31 97       	sbiw	r30, 0x01	; 1
     55c:	36 e1       	ldi	r19, 0x16	; 22
     55e:	30 83       	st	Z, r19
     560:	31 97       	sbiw	r30, 0x01	; 1
     562:	37 e1       	ldi	r19, 0x17	; 23
     564:	30 83       	st	Z, r19
     566:	31 97       	sbiw	r30, 0x01	; 1
     568:	38 e1       	ldi	r19, 0x18	; 24
     56a:	30 83       	st	Z, r19
     56c:	31 97       	sbiw	r30, 0x01	; 1
     56e:	39 e1       	ldi	r19, 0x19	; 25
     570:	30 83       	st	Z, r19
     572:	31 97       	sbiw	r30, 0x01	; 1
     574:	30 e2       	ldi	r19, 0x20	; 32
     576:	30 83       	st	Z, r19
     578:	31 97       	sbiw	r30, 0x01	; 1
     57a:	31 e2       	ldi	r19, 0x21	; 33
     57c:	30 83       	st	Z, r19
     57e:	31 97       	sbiw	r30, 0x01	; 1
     580:	20 83       	st	Z, r18
     582:	31 97       	sbiw	r30, 0x01	; 1
     584:	23 e2       	ldi	r18, 0x23	; 35
     586:	20 83       	st	Z, r18
     588:	31 97       	sbiw	r30, 0x01	; 1
     58a:	40 83       	st	Z, r20
     58c:	31 97       	sbiw	r30, 0x01	; 1
     58e:	50 83       	st	Z, r21
     590:	31 97       	sbiw	r30, 0x01	; 1
     592:	26 e2       	ldi	r18, 0x26	; 38
     594:	20 83       	st	Z, r18
     596:	31 97       	sbiw	r30, 0x01	; 1
     598:	27 e2       	ldi	r18, 0x27	; 39
     59a:	20 83       	st	Z, r18
     59c:	31 97       	sbiw	r30, 0x01	; 1
     59e:	28 e2       	ldi	r18, 0x28	; 40
     5a0:	20 83       	st	Z, r18
     5a2:	31 97       	sbiw	r30, 0x01	; 1
     5a4:	29 e2       	ldi	r18, 0x29	; 41
     5a6:	20 83       	st	Z, r18
     5a8:	31 97       	sbiw	r30, 0x01	; 1
     5aa:	20 e3       	ldi	r18, 0x30	; 48
     5ac:	20 83       	st	Z, r18
     5ae:	31 97       	sbiw	r30, 0x01	; 1
     5b0:	21 e3       	ldi	r18, 0x31	; 49
     5b2:	20 83       	st	Z, r18
     5b4:	86 97       	sbiw	r24, 0x26	; 38
     5b6:	08 95       	ret

000005b8 <xPortStartScheduler>:
     5b8:	1b bc       	out	0x2b, r1	; 43
     5ba:	8c e7       	ldi	r24, 0x7C	; 124
     5bc:	8a bd       	out	0x2a, r24	; 42
     5be:	8b e0       	ldi	r24, 0x0B	; 11
     5c0:	8e bd       	out	0x2e, r24	; 46
     5c2:	89 b7       	in	r24, 0x39	; 57
     5c4:	80 61       	ori	r24, 0x10	; 16
     5c6:	89 bf       	out	0x39, r24	; 57
     5c8:	a0 91 7b 03 	lds	r26, 0x037B	; 0x80037b <pxCurrentTCB>
     5cc:	b0 91 7c 03 	lds	r27, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
     5d0:	cd 91       	ld	r28, X+
     5d2:	cd bf       	out	0x3d, r28	; 61
     5d4:	dd 91       	ld	r29, X+
     5d6:	de bf       	out	0x3e, r29	; 62
     5d8:	ff 91       	pop	r31
     5da:	ef 91       	pop	r30
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	bf 91       	pop	r27
     5e2:	af 91       	pop	r26
     5e4:	9f 91       	pop	r25
     5e6:	8f 91       	pop	r24
     5e8:	7f 91       	pop	r23
     5ea:	6f 91       	pop	r22
     5ec:	5f 91       	pop	r21
     5ee:	4f 91       	pop	r20
     5f0:	3f 91       	pop	r19
     5f2:	2f 91       	pop	r18
     5f4:	1f 91       	pop	r17
     5f6:	0f 91       	pop	r16
     5f8:	ff 90       	pop	r15
     5fa:	ef 90       	pop	r14
     5fc:	df 90       	pop	r13
     5fe:	cf 90       	pop	r12
     600:	bf 90       	pop	r11
     602:	af 90       	pop	r10
     604:	9f 90       	pop	r9
     606:	8f 90       	pop	r8
     608:	7f 90       	pop	r7
     60a:	6f 90       	pop	r6
     60c:	5f 90       	pop	r5
     60e:	4f 90       	pop	r4
     610:	3f 90       	pop	r3
     612:	2f 90       	pop	r2
     614:	1f 90       	pop	r1
     616:	0f 90       	pop	r0
     618:	0f be       	out	0x3f, r0	; 63
     61a:	0f 90       	pop	r0
     61c:	08 95       	ret
     61e:	81 e0       	ldi	r24, 0x01	; 1
     620:	08 95       	ret

00000622 <vPortYield>:
     622:	0f 92       	push	r0
     624:	0f b6       	in	r0, 0x3f	; 63
     626:	f8 94       	cli
     628:	0f 92       	push	r0
     62a:	1f 92       	push	r1
     62c:	11 24       	eor	r1, r1
     62e:	2f 92       	push	r2
     630:	3f 92       	push	r3
     632:	4f 92       	push	r4
     634:	5f 92       	push	r5
     636:	6f 92       	push	r6
     638:	7f 92       	push	r7
     63a:	8f 92       	push	r8
     63c:	9f 92       	push	r9
     63e:	af 92       	push	r10
     640:	bf 92       	push	r11
     642:	cf 92       	push	r12
     644:	df 92       	push	r13
     646:	ef 92       	push	r14
     648:	ff 92       	push	r15
     64a:	0f 93       	push	r16
     64c:	1f 93       	push	r17
     64e:	2f 93       	push	r18
     650:	3f 93       	push	r19
     652:	4f 93       	push	r20
     654:	5f 93       	push	r21
     656:	6f 93       	push	r22
     658:	7f 93       	push	r23
     65a:	8f 93       	push	r24
     65c:	9f 93       	push	r25
     65e:	af 93       	push	r26
     660:	bf 93       	push	r27
     662:	cf 93       	push	r28
     664:	df 93       	push	r29
     666:	ef 93       	push	r30
     668:	ff 93       	push	r31
     66a:	a0 91 7b 03 	lds	r26, 0x037B	; 0x80037b <pxCurrentTCB>
     66e:	b0 91 7c 03 	lds	r27, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
     672:	0d b6       	in	r0, 0x3d	; 61
     674:	0d 92       	st	X+, r0
     676:	0e b6       	in	r0, 0x3e	; 62
     678:	0d 92       	st	X+, r0
     67a:	0e 94 24 0b 	call	0x1648	; 0x1648 <vTaskSwitchContext>
     67e:	a0 91 7b 03 	lds	r26, 0x037B	; 0x80037b <pxCurrentTCB>
     682:	b0 91 7c 03 	lds	r27, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
     686:	cd 91       	ld	r28, X+
     688:	cd bf       	out	0x3d, r28	; 61
     68a:	dd 91       	ld	r29, X+
     68c:	de bf       	out	0x3e, r29	; 62
     68e:	ff 91       	pop	r31
     690:	ef 91       	pop	r30
     692:	df 91       	pop	r29
     694:	cf 91       	pop	r28
     696:	bf 91       	pop	r27
     698:	af 91       	pop	r26
     69a:	9f 91       	pop	r25
     69c:	8f 91       	pop	r24
     69e:	7f 91       	pop	r23
     6a0:	6f 91       	pop	r22
     6a2:	5f 91       	pop	r21
     6a4:	4f 91       	pop	r20
     6a6:	3f 91       	pop	r19
     6a8:	2f 91       	pop	r18
     6aa:	1f 91       	pop	r17
     6ac:	0f 91       	pop	r16
     6ae:	ff 90       	pop	r15
     6b0:	ef 90       	pop	r14
     6b2:	df 90       	pop	r13
     6b4:	cf 90       	pop	r12
     6b6:	bf 90       	pop	r11
     6b8:	af 90       	pop	r10
     6ba:	9f 90       	pop	r9
     6bc:	8f 90       	pop	r8
     6be:	7f 90       	pop	r7
     6c0:	6f 90       	pop	r6
     6c2:	5f 90       	pop	r5
     6c4:	4f 90       	pop	r4
     6c6:	3f 90       	pop	r3
     6c8:	2f 90       	pop	r2
     6ca:	1f 90       	pop	r1
     6cc:	0f 90       	pop	r0
     6ce:	0f be       	out	0x3f, r0	; 63
     6d0:	0f 90       	pop	r0
     6d2:	08 95       	ret

000006d4 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
     6d4:	1f 92       	push	r1
     6d6:	0f 92       	push	r0
     6d8:	0f b6       	in	r0, 0x3f	; 63
     6da:	0f 92       	push	r0
     6dc:	11 24       	eor	r1, r1
     6de:	2f 93       	push	r18
     6e0:	3f 93       	push	r19
     6e2:	4f 93       	push	r20
     6e4:	5f 93       	push	r21
     6e6:	6f 93       	push	r22
     6e8:	7f 93       	push	r23
     6ea:	8f 93       	push	r24
     6ec:	9f 93       	push	r25
     6ee:	af 93       	push	r26
     6f0:	bf 93       	push	r27
     6f2:	ef 93       	push	r30
     6f4:	ff 93       	push	r31
		vTaskIncrementTick();
     6f6:	0e 94 3f 09 	call	0x127e	; 0x127e <vTaskIncrementTick>
	}
     6fa:	ff 91       	pop	r31
     6fc:	ef 91       	pop	r30
     6fe:	bf 91       	pop	r27
     700:	af 91       	pop	r26
     702:	9f 91       	pop	r25
     704:	8f 91       	pop	r24
     706:	7f 91       	pop	r23
     708:	6f 91       	pop	r22
     70a:	5f 91       	pop	r21
     70c:	4f 91       	pop	r20
     70e:	3f 91       	pop	r19
     710:	2f 91       	pop	r18
     712:	0f 90       	pop	r0
     714:	0f be       	out	0x3f, r0	; 63
     716:	0f 90       	pop	r0
     718:	1f 90       	pop	r1
     71a:	18 95       	reti

0000071c <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     71c:	cf 93       	push	r28
     71e:	df 93       	push	r29
     720:	ec 01       	movw	r28, r24
     722:	8c 8d       	ldd	r24, Y+28	; 0x1c
     724:	88 23       	and	r24, r24
     726:	a9 f1       	breq	.+106    	; 0x792 <prvCopyDataToQueue+0x76>
     728:	41 11       	cpse	r20, r1
     72a:	17 c0       	rjmp	.+46     	; 0x75a <prvCopyDataToQueue+0x3e>
     72c:	48 2f       	mov	r20, r24
     72e:	50 e0       	ldi	r21, 0x00	; 0
     730:	8c 81       	ldd	r24, Y+4	; 0x04
     732:	9d 81       	ldd	r25, Y+5	; 0x05
     734:	0e 94 84 0c 	call	0x1908	; 0x1908 <memcpy>
     738:	2c 8d       	ldd	r18, Y+28	; 0x1c
     73a:	8c 81       	ldd	r24, Y+4	; 0x04
     73c:	9d 81       	ldd	r25, Y+5	; 0x05
     73e:	82 0f       	add	r24, r18
     740:	91 1d       	adc	r25, r1
     742:	9d 83       	std	Y+5, r25	; 0x05
     744:	8c 83       	std	Y+4, r24	; 0x04
     746:	2a 81       	ldd	r18, Y+2	; 0x02
     748:	3b 81       	ldd	r19, Y+3	; 0x03
     74a:	82 17       	cp	r24, r18
     74c:	93 07       	cpc	r25, r19
     74e:	08 f1       	brcs	.+66     	; 0x792 <prvCopyDataToQueue+0x76>
     750:	88 81       	ld	r24, Y
     752:	99 81       	ldd	r25, Y+1	; 0x01
     754:	9d 83       	std	Y+5, r25	; 0x05
     756:	8c 83       	std	Y+4, r24	; 0x04
     758:	1c c0       	rjmp	.+56     	; 0x792 <prvCopyDataToQueue+0x76>
     75a:	48 2f       	mov	r20, r24
     75c:	50 e0       	ldi	r21, 0x00	; 0
     75e:	8e 81       	ldd	r24, Y+6	; 0x06
     760:	9f 81       	ldd	r25, Y+7	; 0x07
     762:	0e 94 84 0c 	call	0x1908	; 0x1908 <memcpy>
     766:	8c 8d       	ldd	r24, Y+28	; 0x1c
     768:	90 e0       	ldi	r25, 0x00	; 0
     76a:	91 95       	neg	r25
     76c:	81 95       	neg	r24
     76e:	91 09       	sbc	r25, r1
     770:	2e 81       	ldd	r18, Y+6	; 0x06
     772:	3f 81       	ldd	r19, Y+7	; 0x07
     774:	28 0f       	add	r18, r24
     776:	39 1f       	adc	r19, r25
     778:	3f 83       	std	Y+7, r19	; 0x07
     77a:	2e 83       	std	Y+6, r18	; 0x06
     77c:	48 81       	ld	r20, Y
     77e:	59 81       	ldd	r21, Y+1	; 0x01
     780:	24 17       	cp	r18, r20
     782:	35 07       	cpc	r19, r21
     784:	30 f4       	brcc	.+12     	; 0x792 <prvCopyDataToQueue+0x76>
     786:	2a 81       	ldd	r18, Y+2	; 0x02
     788:	3b 81       	ldd	r19, Y+3	; 0x03
     78a:	82 0f       	add	r24, r18
     78c:	93 1f       	adc	r25, r19
     78e:	9f 83       	std	Y+7, r25	; 0x07
     790:	8e 83       	std	Y+6, r24	; 0x06
     792:	8a 8d       	ldd	r24, Y+26	; 0x1a
     794:	8f 5f       	subi	r24, 0xFF	; 255
     796:	8a 8f       	std	Y+26, r24	; 0x1a
     798:	df 91       	pop	r29
     79a:	cf 91       	pop	r28
     79c:	08 95       	ret

0000079e <prvCopyDataFromQueue>:
     79e:	fc 01       	movw	r30, r24
     7a0:	80 81       	ld	r24, Z
     7a2:	91 81       	ldd	r25, Z+1	; 0x01
     7a4:	00 97       	sbiw	r24, 0x00	; 0
     7a6:	a1 f0       	breq	.+40     	; 0x7d0 <prvCopyDataFromQueue+0x32>
     7a8:	44 8d       	ldd	r20, Z+28	; 0x1c
     7aa:	50 e0       	ldi	r21, 0x00	; 0
     7ac:	26 81       	ldd	r18, Z+6	; 0x06
     7ae:	37 81       	ldd	r19, Z+7	; 0x07
     7b0:	24 0f       	add	r18, r20
     7b2:	35 1f       	adc	r19, r21
     7b4:	37 83       	std	Z+7, r19	; 0x07
     7b6:	26 83       	std	Z+6, r18	; 0x06
     7b8:	a2 81       	ldd	r26, Z+2	; 0x02
     7ba:	b3 81       	ldd	r27, Z+3	; 0x03
     7bc:	2a 17       	cp	r18, r26
     7be:	3b 07       	cpc	r19, r27
     7c0:	10 f0       	brcs	.+4      	; 0x7c6 <prvCopyDataFromQueue+0x28>
     7c2:	97 83       	std	Z+7, r25	; 0x07
     7c4:	86 83       	std	Z+6, r24	; 0x06
     7c6:	cb 01       	movw	r24, r22
     7c8:	66 81       	ldd	r22, Z+6	; 0x06
     7ca:	77 81       	ldd	r23, Z+7	; 0x07
     7cc:	0e 94 84 0c 	call	0x1908	; 0x1908 <memcpy>
     7d0:	08 95       	ret

000007d2 <prvUnlockQueue>:
     7d2:	0f 93       	push	r16
     7d4:	1f 93       	push	r17
     7d6:	cf 93       	push	r28
     7d8:	df 93       	push	r29
     7da:	ec 01       	movw	r28, r24
     7dc:	0f b6       	in	r0, 0x3f	; 63
     7de:	f8 94       	cli
     7e0:	0f 92       	push	r0
     7e2:	8e 8d       	ldd	r24, Y+30	; 0x1e
     7e4:	18 16       	cp	r1, r24
     7e6:	b4 f4       	brge	.+44     	; 0x814 <prvUnlockQueue+0x42>
     7e8:	89 89       	ldd	r24, Y+17	; 0x11
     7ea:	81 11       	cpse	r24, r1
     7ec:	05 c0       	rjmp	.+10     	; 0x7f8 <prvUnlockQueue+0x26>
     7ee:	12 c0       	rjmp	.+36     	; 0x814 <prvUnlockQueue+0x42>
     7f0:	89 89       	ldd	r24, Y+17	; 0x11
     7f2:	81 11       	cpse	r24, r1
     7f4:	04 c0       	rjmp	.+8      	; 0x7fe <prvUnlockQueue+0x2c>
     7f6:	0e c0       	rjmp	.+28     	; 0x814 <prvUnlockQueue+0x42>
     7f8:	8e 01       	movw	r16, r28
     7fa:	0f 5e       	subi	r16, 0xEF	; 239
     7fc:	1f 4f       	sbci	r17, 0xFF	; 255
     7fe:	c8 01       	movw	r24, r16
     800:	0e 94 ad 0b 	call	0x175a	; 0x175a <xTaskRemoveFromEventList>
     804:	81 11       	cpse	r24, r1
     806:	0e 94 34 0c 	call	0x1868	; 0x1868 <vTaskMissedYield>
     80a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     80c:	81 50       	subi	r24, 0x01	; 1
     80e:	8e 8f       	std	Y+30, r24	; 0x1e
     810:	18 16       	cp	r1, r24
     812:	74 f3       	brlt	.-36     	; 0x7f0 <prvUnlockQueue+0x1e>
     814:	8f ef       	ldi	r24, 0xFF	; 255
     816:	8e 8f       	std	Y+30, r24	; 0x1e
     818:	0f 90       	pop	r0
     81a:	0f be       	out	0x3f, r0	; 63
     81c:	0f b6       	in	r0, 0x3f	; 63
     81e:	f8 94       	cli
     820:	0f 92       	push	r0
     822:	8d 8d       	ldd	r24, Y+29	; 0x1d
     824:	18 16       	cp	r1, r24
     826:	b4 f4       	brge	.+44     	; 0x854 <prvUnlockQueue+0x82>
     828:	88 85       	ldd	r24, Y+8	; 0x08
     82a:	81 11       	cpse	r24, r1
     82c:	05 c0       	rjmp	.+10     	; 0x838 <prvUnlockQueue+0x66>
     82e:	12 c0       	rjmp	.+36     	; 0x854 <prvUnlockQueue+0x82>
     830:	88 85       	ldd	r24, Y+8	; 0x08
     832:	81 11       	cpse	r24, r1
     834:	04 c0       	rjmp	.+8      	; 0x83e <prvUnlockQueue+0x6c>
     836:	0e c0       	rjmp	.+28     	; 0x854 <prvUnlockQueue+0x82>
     838:	8e 01       	movw	r16, r28
     83a:	08 5f       	subi	r16, 0xF8	; 248
     83c:	1f 4f       	sbci	r17, 0xFF	; 255
     83e:	c8 01       	movw	r24, r16
     840:	0e 94 ad 0b 	call	0x175a	; 0x175a <xTaskRemoveFromEventList>
     844:	81 11       	cpse	r24, r1
     846:	0e 94 34 0c 	call	0x1868	; 0x1868 <vTaskMissedYield>
     84a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     84c:	81 50       	subi	r24, 0x01	; 1
     84e:	8d 8f       	std	Y+29, r24	; 0x1d
     850:	18 16       	cp	r1, r24
     852:	74 f3       	brlt	.-36     	; 0x830 <prvUnlockQueue+0x5e>
     854:	8f ef       	ldi	r24, 0xFF	; 255
     856:	8d 8f       	std	Y+29, r24	; 0x1d
     858:	0f 90       	pop	r0
     85a:	0f be       	out	0x3f, r0	; 63
     85c:	df 91       	pop	r29
     85e:	cf 91       	pop	r28
     860:	1f 91       	pop	r17
     862:	0f 91       	pop	r16
     864:	08 95       	ret

00000866 <xQueueGenericSend>:
     866:	9f 92       	push	r9
     868:	af 92       	push	r10
     86a:	bf 92       	push	r11
     86c:	cf 92       	push	r12
     86e:	df 92       	push	r13
     870:	ef 92       	push	r14
     872:	ff 92       	push	r15
     874:	0f 93       	push	r16
     876:	1f 93       	push	r17
     878:	cf 93       	push	r28
     87a:	df 93       	push	r29
     87c:	00 d0       	rcall	.+0      	; 0x87e <xQueueGenericSend+0x18>
     87e:	00 d0       	rcall	.+0      	; 0x880 <xQueueGenericSend+0x1a>
     880:	1f 92       	push	r1
     882:	cd b7       	in	r28, 0x3d	; 61
     884:	de b7       	in	r29, 0x3e	; 62
     886:	8c 01       	movw	r16, r24
     888:	6b 01       	movw	r12, r22
     88a:	5d 83       	std	Y+5, r21	; 0x05
     88c:	4c 83       	std	Y+4, r20	; 0x04
     88e:	92 2e       	mov	r9, r18
     890:	b1 2c       	mov	r11, r1
     892:	aa 24       	eor	r10, r10
     894:	a3 94       	inc	r10
     896:	7c 01       	movw	r14, r24
     898:	88 e0       	ldi	r24, 0x08	; 8
     89a:	e8 0e       	add	r14, r24
     89c:	f1 1c       	adc	r15, r1
     89e:	0f b6       	in	r0, 0x3f	; 63
     8a0:	f8 94       	cli
     8a2:	0f 92       	push	r0
     8a4:	f8 01       	movw	r30, r16
     8a6:	92 8d       	ldd	r25, Z+26	; 0x1a
     8a8:	83 8d       	ldd	r24, Z+27	; 0x1b
     8aa:	98 17       	cp	r25, r24
     8ac:	a8 f4       	brcc	.+42     	; 0x8d8 <xQueueGenericSend+0x72>
     8ae:	49 2d       	mov	r20, r9
     8b0:	b6 01       	movw	r22, r12
     8b2:	c8 01       	movw	r24, r16
     8b4:	0e 94 8e 03 	call	0x71c	; 0x71c <prvCopyDataToQueue>
     8b8:	f8 01       	movw	r30, r16
     8ba:	81 89       	ldd	r24, Z+17	; 0x11
     8bc:	88 23       	and	r24, r24
     8be:	41 f0       	breq	.+16     	; 0x8d0 <xQueueGenericSend+0x6a>
     8c0:	c8 01       	movw	r24, r16
     8c2:	41 96       	adiw	r24, 0x11	; 17
     8c4:	0e 94 ad 0b 	call	0x175a	; 0x175a <xTaskRemoveFromEventList>
     8c8:	81 30       	cpi	r24, 0x01	; 1
     8ca:	11 f4       	brne	.+4      	; 0x8d0 <xQueueGenericSend+0x6a>
     8cc:	0e 94 11 03 	call	0x622	; 0x622 <vPortYield>
     8d0:	0f 90       	pop	r0
     8d2:	0f be       	out	0x3f, r0	; 63
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	50 c0       	rjmp	.+160    	; 0x978 <xQueueGenericSend+0x112>
     8d8:	8c 81       	ldd	r24, Y+4	; 0x04
     8da:	9d 81       	ldd	r25, Y+5	; 0x05
     8dc:	89 2b       	or	r24, r25
     8de:	21 f4       	brne	.+8      	; 0x8e8 <xQueueGenericSend+0x82>
     8e0:	0f 90       	pop	r0
     8e2:	0f be       	out	0x3f, r0	; 63
     8e4:	80 e0       	ldi	r24, 0x00	; 0
     8e6:	48 c0       	rjmp	.+144    	; 0x978 <xQueueGenericSend+0x112>
     8e8:	b1 10       	cpse	r11, r1
     8ea:	05 c0       	rjmp	.+10     	; 0x8f6 <xQueueGenericSend+0x90>
     8ec:	ce 01       	movw	r24, r28
     8ee:	01 96       	adiw	r24, 0x01	; 1
     8f0:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vTaskSetTimeOutState>
     8f4:	ba 2c       	mov	r11, r10
     8f6:	0f 90       	pop	r0
     8f8:	0f be       	out	0x3f, r0	; 63
     8fa:	0e 94 2f 09 	call	0x125e	; 0x125e <vTaskSuspendAll>
     8fe:	0f b6       	in	r0, 0x3f	; 63
     900:	f8 94       	cli
     902:	0f 92       	push	r0
     904:	f8 01       	movw	r30, r16
     906:	85 8d       	ldd	r24, Z+29	; 0x1d
     908:	8f 3f       	cpi	r24, 0xFF	; 255
     90a:	09 f4       	brne	.+2      	; 0x90e <xQueueGenericSend+0xa8>
     90c:	15 8e       	std	Z+29, r1	; 0x1d
     90e:	f8 01       	movw	r30, r16
     910:	86 8d       	ldd	r24, Z+30	; 0x1e
     912:	8f 3f       	cpi	r24, 0xFF	; 255
     914:	09 f4       	brne	.+2      	; 0x918 <xQueueGenericSend+0xb2>
     916:	16 8e       	std	Z+30, r1	; 0x1e
     918:	0f 90       	pop	r0
     91a:	0f be       	out	0x3f, r0	; 63
     91c:	be 01       	movw	r22, r28
     91e:	6c 5f       	subi	r22, 0xFC	; 252
     920:	7f 4f       	sbci	r23, 0xFF	; 255
     922:	ce 01       	movw	r24, r28
     924:	01 96       	adiw	r24, 0x01	; 1
     926:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xTaskCheckForTimeOut>
     92a:	81 11       	cpse	r24, r1
     92c:	1f c0       	rjmp	.+62     	; 0x96c <xQueueGenericSend+0x106>
     92e:	0f b6       	in	r0, 0x3f	; 63
     930:	f8 94       	cli
     932:	0f 92       	push	r0
     934:	f8 01       	movw	r30, r16
     936:	92 8d       	ldd	r25, Z+26	; 0x1a
     938:	0f 90       	pop	r0
     93a:	0f be       	out	0x3f, r0	; 63
     93c:	83 8d       	ldd	r24, Z+27	; 0x1b
     93e:	98 13       	cpse	r25, r24
     940:	0f c0       	rjmp	.+30     	; 0x960 <xQueueGenericSend+0xfa>
     942:	6c 81       	ldd	r22, Y+4	; 0x04
     944:	7d 81       	ldd	r23, Y+5	; 0x05
     946:	c7 01       	movw	r24, r14
     948:	0e 94 90 0b 	call	0x1720	; 0x1720 <vTaskPlaceOnEventList>
     94c:	c8 01       	movw	r24, r16
     94e:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <prvUnlockQueue>
     952:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskResumeAll>
     956:	81 11       	cpse	r24, r1
     958:	a2 cf       	rjmp	.-188    	; 0x89e <xQueueGenericSend+0x38>
     95a:	0e 94 11 03 	call	0x622	; 0x622 <vPortYield>
     95e:	9f cf       	rjmp	.-194    	; 0x89e <xQueueGenericSend+0x38>
     960:	c8 01       	movw	r24, r16
     962:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <prvUnlockQueue>
     966:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskResumeAll>
     96a:	99 cf       	rjmp	.-206    	; 0x89e <xQueueGenericSend+0x38>
     96c:	c8 01       	movw	r24, r16
     96e:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <prvUnlockQueue>
     972:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskResumeAll>
     976:	80 e0       	ldi	r24, 0x00	; 0
     978:	0f 90       	pop	r0
     97a:	0f 90       	pop	r0
     97c:	0f 90       	pop	r0
     97e:	0f 90       	pop	r0
     980:	0f 90       	pop	r0
     982:	df 91       	pop	r29
     984:	cf 91       	pop	r28
     986:	1f 91       	pop	r17
     988:	0f 91       	pop	r16
     98a:	ff 90       	pop	r15
     98c:	ef 90       	pop	r14
     98e:	df 90       	pop	r13
     990:	cf 90       	pop	r12
     992:	bf 90       	pop	r11
     994:	af 90       	pop	r10
     996:	9f 90       	pop	r9
     998:	08 95       	ret

0000099a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     99a:	9f 92       	push	r9
     99c:	af 92       	push	r10
     99e:	bf 92       	push	r11
     9a0:	cf 92       	push	r12
     9a2:	df 92       	push	r13
     9a4:	ef 92       	push	r14
     9a6:	ff 92       	push	r15
     9a8:	0f 93       	push	r16
     9aa:	1f 93       	push	r17
     9ac:	cf 93       	push	r28
     9ae:	df 93       	push	r29
     9b0:	00 d0       	rcall	.+0      	; 0x9b2 <xQueueGenericReceive+0x18>
     9b2:	00 d0       	rcall	.+0      	; 0x9b4 <xQueueGenericReceive+0x1a>
     9b4:	1f 92       	push	r1
     9b6:	cd b7       	in	r28, 0x3d	; 61
     9b8:	de b7       	in	r29, 0x3e	; 62
     9ba:	8c 01       	movw	r16, r24
     9bc:	6b 01       	movw	r12, r22
     9be:	5d 83       	std	Y+5, r21	; 0x05
     9c0:	4c 83       	std	Y+4, r20	; 0x04
     9c2:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     9c4:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     9c6:	aa 24       	eor	r10, r10
     9c8:	a3 94       	inc	r10
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     9ca:	7c 01       	movw	r14, r24
     9cc:	81 e1       	ldi	r24, 0x11	; 17
     9ce:	e8 0e       	add	r14, r24
     9d0:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     9d2:	0f b6       	in	r0, 0x3f	; 63
     9d4:	f8 94       	cli
     9d6:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     9d8:	f8 01       	movw	r30, r16
     9da:	82 8d       	ldd	r24, Z+26	; 0x1a
     9dc:	88 23       	and	r24, r24
     9de:	49 f1       	breq	.+82     	; 0xa32 <xQueueGenericReceive+0x98>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     9e0:	e6 80       	ldd	r14, Z+6	; 0x06
     9e2:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     9e4:	b6 01       	movw	r22, r12
     9e6:	c8 01       	movw	r24, r16
     9e8:	0e 94 cf 03 	call	0x79e	; 0x79e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     9ec:	91 10       	cpse	r9, r1
     9ee:	10 c0       	rjmp	.+32     	; 0xa10 <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     9f0:	f8 01       	movw	r30, r16
     9f2:	82 8d       	ldd	r24, Z+26	; 0x1a
     9f4:	81 50       	subi	r24, 0x01	; 1
     9f6:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     9f8:	80 85       	ldd	r24, Z+8	; 0x08
     9fa:	88 23       	and	r24, r24
     9fc:	b1 f0       	breq	.+44     	; 0xa2a <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     9fe:	c8 01       	movw	r24, r16
     a00:	08 96       	adiw	r24, 0x08	; 8
     a02:	0e 94 ad 0b 	call	0x175a	; 0x175a <xTaskRemoveFromEventList>
     a06:	81 30       	cpi	r24, 0x01	; 1
     a08:	81 f4       	brne	.+32     	; 0xa2a <xQueueGenericReceive+0x90>
						{
							portYIELD_WITHIN_API();
     a0a:	0e 94 11 03 	call	0x622	; 0x622 <vPortYield>
     a0e:	0d c0       	rjmp	.+26     	; 0xa2a <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     a10:	f8 01       	movw	r30, r16
     a12:	f7 82       	std	Z+7, r15	; 0x07
     a14:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a16:	81 89       	ldd	r24, Z+17	; 0x11
     a18:	88 23       	and	r24, r24
     a1a:	39 f0       	breq	.+14     	; 0xa2a <xQueueGenericReceive+0x90>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a1c:	c8 01       	movw	r24, r16
     a1e:	41 96       	adiw	r24, 0x11	; 17
     a20:	0e 94 ad 0b 	call	0x175a	; 0x175a <xTaskRemoveFromEventList>
     a24:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     a26:	0e 94 11 03 	call	0x622	; 0x622 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     a2a:	0f 90       	pop	r0
     a2c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     a2e:	81 e0       	ldi	r24, 0x01	; 1
     a30:	4f c0       	rjmp	.+158    	; 0xad0 <xQueueGenericReceive+0x136>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     a32:	8c 81       	ldd	r24, Y+4	; 0x04
     a34:	9d 81       	ldd	r25, Y+5	; 0x05
     a36:	89 2b       	or	r24, r25
     a38:	21 f4       	brne	.+8      	; 0xa42 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     a3a:	0f 90       	pop	r0
     a3c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     a3e:	80 e0       	ldi	r24, 0x00	; 0
     a40:	47 c0       	rjmp	.+142    	; 0xad0 <xQueueGenericReceive+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
     a42:	b1 10       	cpse	r11, r1
     a44:	05 c0       	rjmp	.+10     	; 0xa50 <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     a46:	ce 01       	movw	r24, r28
     a48:	01 96       	adiw	r24, 0x01	; 1
     a4a:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     a4e:	ba 2c       	mov	r11, r10
				}
			}
		}
		taskEXIT_CRITICAL();
     a50:	0f 90       	pop	r0
     a52:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     a54:	0e 94 2f 09 	call	0x125e	; 0x125e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     a58:	0f b6       	in	r0, 0x3f	; 63
     a5a:	f8 94       	cli
     a5c:	0f 92       	push	r0
     a5e:	f8 01       	movw	r30, r16
     a60:	85 8d       	ldd	r24, Z+29	; 0x1d
     a62:	8f 3f       	cpi	r24, 0xFF	; 255
     a64:	09 f4       	brne	.+2      	; 0xa68 <xQueueGenericReceive+0xce>
     a66:	15 8e       	std	Z+29, r1	; 0x1d
     a68:	f8 01       	movw	r30, r16
     a6a:	86 8d       	ldd	r24, Z+30	; 0x1e
     a6c:	8f 3f       	cpi	r24, 0xFF	; 255
     a6e:	09 f4       	brne	.+2      	; 0xa72 <xQueueGenericReceive+0xd8>
     a70:	16 8e       	std	Z+30, r1	; 0x1e
     a72:	0f 90       	pop	r0
     a74:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     a76:	be 01       	movw	r22, r28
     a78:	6c 5f       	subi	r22, 0xFC	; 252
     a7a:	7f 4f       	sbci	r23, 0xFF	; 255
     a7c:	ce 01       	movw	r24, r28
     a7e:	01 96       	adiw	r24, 0x01	; 1
     a80:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xTaskCheckForTimeOut>
     a84:	81 11       	cpse	r24, r1
     a86:	1e c0       	rjmp	.+60     	; 0xac4 <xQueueGenericReceive+0x12a>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     a88:	0f b6       	in	r0, 0x3f	; 63
     a8a:	f8 94       	cli
     a8c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     a8e:	f8 01       	movw	r30, r16
     a90:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     a92:	0f 90       	pop	r0
     a94:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     a96:	81 11       	cpse	r24, r1
     a98:	0f c0       	rjmp	.+30     	; 0xab8 <xQueueGenericReceive+0x11e>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     a9a:	6c 81       	ldd	r22, Y+4	; 0x04
     a9c:	7d 81       	ldd	r23, Y+5	; 0x05
     a9e:	c7 01       	movw	r24, r14
     aa0:	0e 94 90 0b 	call	0x1720	; 0x1720 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     aa4:	c8 01       	movw	r24, r16
     aa6:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     aaa:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskResumeAll>
     aae:	81 11       	cpse	r24, r1
     ab0:	90 cf       	rjmp	.-224    	; 0x9d2 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     ab2:	0e 94 11 03 	call	0x622	; 0x622 <vPortYield>
     ab6:	8d cf       	rjmp	.-230    	; 0x9d2 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     ab8:	c8 01       	movw	r24, r16
     aba:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     abe:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskResumeAll>
     ac2:	87 cf       	rjmp	.-242    	; 0x9d2 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     ac4:	c8 01       	movw	r24, r16
     ac6:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     aca:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     ace:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     ad0:	0f 90       	pop	r0
     ad2:	0f 90       	pop	r0
     ad4:	0f 90       	pop	r0
     ad6:	0f 90       	pop	r0
     ad8:	0f 90       	pop	r0
     ada:	df 91       	pop	r29
     adc:	cf 91       	pop	r28
     ade:	1f 91       	pop	r17
     ae0:	0f 91       	pop	r16
     ae2:	ff 90       	pop	r15
     ae4:	ef 90       	pop	r14
     ae6:	df 90       	pop	r13
     ae8:	cf 90       	pop	r12
     aea:	bf 90       	pop	r11
     aec:	af 90       	pop	r10
     aee:	9f 90       	pop	r9
     af0:	08 95       	ret

00000af2 <main>:
				break;
			case 3:
				DIO_voidSetPin(ledpin,0);
				mode = 0;
				vTaskDelayUntil(&x,250);
				break;
     af2:	af 92       	push	r10
     af4:	bf 92       	push	r11
     af6:	cf 92       	push	r12
     af8:	df 92       	push	r13
     afa:	ef 92       	push	r14
     afc:	ff 92       	push	r15
     afe:	0f 93       	push	r16
     b00:	cf 93       	push	r28
     b02:	df 93       	push	r29
     b04:	00 d0       	rcall	.+0      	; 0xb06 <main+0x14>
     b06:	00 d0       	rcall	.+0      	; 0xb08 <main+0x16>
     b08:	cd b7       	in	r28, 0x3d	; 61
     b0a:	de b7       	in	r29, 0x3e	; 62
     b0c:	0e 94 73 01 	call	0x2e6	; 0x2e6 <lcd_init>
     b10:	8f ef       	ldi	r24, 0xFF	; 255
     b12:	8a bb       	out	0x1a, r24	; 26
     b14:	a1 2c       	mov	r10, r1
     b16:	b1 2c       	mov	r11, r1
     b18:	c1 2c       	mov	r12, r1
     b1a:	d1 2c       	mov	r13, r1
     b1c:	ce 01       	movw	r24, r28
     b1e:	01 96       	adiw	r24, 0x01	; 1
     b20:	7c 01       	movw	r14, r24
     b22:	02 e0       	ldi	r16, 0x02	; 2
     b24:	20 e0       	ldi	r18, 0x00	; 0
     b26:	30 e0       	ldi	r19, 0x00	; 0
     b28:	44 e6       	ldi	r20, 0x64	; 100
     b2a:	50 e0       	ldi	r21, 0x00	; 0
     b2c:	60 e0       	ldi	r22, 0x00	; 0
     b2e:	70 e0       	ldi	r23, 0x00	; 0
     b30:	8c e1       	ldi	r24, 0x1C	; 28
     b32:	96 e0       	ldi	r25, 0x06	; 6
     b34:	0e 94 fb 07 	call	0xff6	; 0xff6 <xTaskGenericCreate>
     b38:	ce 01       	movw	r24, r28
     b3a:	03 96       	adiw	r24, 0x03	; 3
     b3c:	7c 01       	movw	r14, r24
     b3e:	01 e0       	ldi	r16, 0x01	; 1
     b40:	20 e0       	ldi	r18, 0x00	; 0
     b42:	30 e0       	ldi	r19, 0x00	; 0
     b44:	44 e6       	ldi	r20, 0x64	; 100
     b46:	50 e0       	ldi	r21, 0x00	; 0
     b48:	60 e0       	ldi	r22, 0x00	; 0
     b4a:	70 e0       	ldi	r23, 0x00	; 0
     b4c:	80 e8       	ldi	r24, 0x80	; 128
     b4e:	97 e0       	ldi	r25, 0x07	; 7
     b50:	0e 94 fb 07 	call	0xff6	; 0xff6 <xTaskGenericCreate>
     b54:	0e 94 04 09 	call	0x1208	; 0x1208 <vTaskStartScheduler>
     b58:	80 e0       	ldi	r24, 0x00	; 0
     b5a:	90 e0       	ldi	r25, 0x00	; 0
     b5c:	0f 90       	pop	r0
     b5e:	0f 90       	pop	r0
     b60:	0f 90       	pop	r0
     b62:	0f 90       	pop	r0
     b64:	df 91       	pop	r29
     b66:	cf 91       	pop	r28
     b68:	0f 91       	pop	r16
     b6a:	ff 90       	pop	r15
     b6c:	ef 90       	pop	r14
     b6e:	df 90       	pop	r13
     b70:	cf 90       	pop	r12
     b72:	bf 90       	pop	r11
     b74:	af 90       	pop	r10
     b76:	08 95       	ret

00000b78 <welcome>:
     b78:	0f 93       	push	r16
     b7a:	1f 93       	push	r17
     b7c:	cf 93       	push	r28
     b7e:	df 93       	push	r29
     b80:	00 d0       	rcall	.+0      	; 0xb82 <welcome+0xa>
     b82:	cd b7       	in	r28, 0x3d	; 61
     b84:	de b7       	in	r29, 0x3e	; 62
     b86:	0e 94 35 09 	call	0x126a	; 0x126a <xTaskGetTickCount>
     b8a:	9a 83       	std	Y+2, r25	; 0x02
     b8c:	89 83       	std	Y+1, r24	; 0x01
     b8e:	00 e0       	ldi	r16, 0x00	; 0
     b90:	10 e0       	ldi	r17, 0x00	; 0
     b92:	62 e3       	ldi	r22, 0x32	; 50
     b94:	70 e0       	ldi	r23, 0x00	; 0
     b96:	ce 01       	movw	r24, r28
     b98:	01 96       	adiw	r24, 0x01	; 1
     b9a:	0e 94 88 0a 	call	0x1510	; 0x1510 <vTaskDelayUntil>
     b9e:	0e 94 b6 01 	call	0x36c	; 0x36c <lcd_clrScreen>
     ba2:	a8 01       	movw	r20, r16
     ba4:	60 e0       	ldi	r22, 0x00	; 0
     ba6:	70 e0       	ldi	r23, 0x00	; 0
     ba8:	83 e6       	ldi	r24, 0x63	; 99
     baa:	90 e0       	ldi	r25, 0x00	; 0
     bac:	0e 94 c9 01 	call	0x392	; 0x392 <lcd_disp_string_xy>
     bb0:	0f 5f       	subi	r16, 0xFF	; 255
     bb2:	1f 4f       	sbci	r17, 0xFF	; 255
     bb4:	0a 30       	cpi	r16, 0x0A	; 10
     bb6:	11 05       	cpc	r17, r1
     bb8:	61 f7       	brne	.-40     	; 0xb92 <welcome+0x1a>
     bba:	09 e0       	ldi	r16, 0x09	; 9
     bbc:	10 e0       	ldi	r17, 0x00	; 0
     bbe:	62 e3       	ldi	r22, 0x32	; 50
     bc0:	70 e0       	ldi	r23, 0x00	; 0
     bc2:	ce 01       	movw	r24, r28
     bc4:	01 96       	adiw	r24, 0x01	; 1
     bc6:	0e 94 88 0a 	call	0x1510	; 0x1510 <vTaskDelayUntil>
     bca:	0e 94 b6 01 	call	0x36c	; 0x36c <lcd_clrScreen>
     bce:	a8 01       	movw	r20, r16
     bd0:	60 e0       	ldi	r22, 0x00	; 0
     bd2:	70 e0       	ldi	r23, 0x00	; 0
     bd4:	83 e6       	ldi	r24, 0x63	; 99
     bd6:	90 e0       	ldi	r25, 0x00	; 0
     bd8:	0e 94 c9 01 	call	0x392	; 0x392 <lcd_disp_string_xy>
     bdc:	01 50       	subi	r16, 0x01	; 1
     bde:	11 09       	sbc	r17, r1
     be0:	71 f7       	brne	.-36     	; 0xbbe <welcome+0x46>
     be2:	0f 90       	pop	r0
     be4:	0f 90       	pop	r0
     be6:	df 91       	pop	r29
     be8:	cf 91       	pop	r28
     bea:	1f 91       	pop	r17
     bec:	0f 91       	pop	r16
     bee:	08 95       	ret

00000bf0 <screen_saver>:
     bf0:	cf 93       	push	r28
     bf2:	df 93       	push	r29
     bf4:	00 d0       	rcall	.+0      	; 0xbf6 <screen_saver+0x6>
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
     bfa:	0e 94 35 09 	call	0x126a	; 0x126a <xTaskGetTickCount>
     bfe:	9a 83       	std	Y+2, r25	; 0x02
     c00:	89 83       	std	Y+1, r24	; 0x01
     c02:	0e 94 b6 01 	call	0x36c	; 0x36c <lcd_clrScreen>
     c06:	6a ef       	ldi	r22, 0xFA	; 250
     c08:	70 e0       	ldi	r23, 0x00	; 0
     c0a:	ce 01       	movw	r24, r28
     c0c:	01 96       	adiw	r24, 0x01	; 1
     c0e:	0e 94 88 0a 	call	0x1510	; 0x1510 <vTaskDelayUntil>
     c12:	8b e6       	ldi	r24, 0x6B	; 107
     c14:	90 e0       	ldi	r25, 0x00	; 0
     c16:	0e 94 ba 01 	call	0x374	; 0x374 <lcd_dispString>
     c1a:	40 e0       	ldi	r20, 0x00	; 0
     c1c:	50 e0       	ldi	r21, 0x00	; 0
     c1e:	61 e0       	ldi	r22, 0x01	; 1
     c20:	70 e0       	ldi	r23, 0x00	; 0
     c22:	89 e7       	ldi	r24, 0x79	; 121
     c24:	90 e0       	ldi	r25, 0x00	; 0
     c26:	0e 94 c9 01 	call	0x392	; 0x392 <lcd_disp_string_xy>
     c2a:	64 ef       	ldi	r22, 0xF4	; 244
     c2c:	71 e0       	ldi	r23, 0x01	; 1
     c2e:	ce 01       	movw	r24, r28
     c30:	01 96       	adiw	r24, 0x01	; 1
     c32:	0e 94 88 0a 	call	0x1510	; 0x1510 <vTaskDelayUntil>
     c36:	e5 cf       	rjmp	.-54     	; 0xc02 <screen_saver+0x12>

00000c38 <task_keypad>:
     c38:	cf 93       	push	r28
     c3a:	df 93       	push	r29
     c3c:	00 d0       	rcall	.+0      	; 0xc3e <task_keypad+0x6>
     c3e:	cd b7       	in	r28, 0x3d	; 61
     c40:	de b7       	in	r29, 0x3e	; 62
     c42:	0e 94 35 09 	call	0x126a	; 0x126a <xTaskGetTickCount>
     c46:	9a 83       	std	Y+2, r25	; 0x02
     c48:	89 83       	std	Y+1, r24	; 0x01
     c4a:	88 e6       	ldi	r24, 0x68	; 104
     c4c:	0e 94 84 01 	call	0x308	; 0x308 <lcd_displayChar>
     c50:	64 e6       	ldi	r22, 0x64	; 100
     c52:	70 e0       	ldi	r23, 0x00	; 0
     c54:	ce 01       	movw	r24, r28
     c56:	01 96       	adiw	r24, 0x01	; 1
     c58:	0e 94 88 0a 	call	0x1510	; 0x1510 <vTaskDelayUntil>
     c5c:	20 e0       	ldi	r18, 0x00	; 0
     c5e:	4f ef       	ldi	r20, 0xFF	; 255
     c60:	5f ef       	ldi	r21, 0xFF	; 255
     c62:	60 e0       	ldi	r22, 0x00	; 0
     c64:	70 e0       	ldi	r23, 0x00	; 0
     c66:	80 91 7f 03 	lds	r24, 0x037F	; 0x80037f <button>
     c6a:	90 91 80 03 	lds	r25, 0x0380	; 0x800380 <button+0x1>
     c6e:	0e 94 cd 04 	call	0x99a	; 0x99a <xQueueGenericReceive>
     c72:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <KeyPad_u8GetPressedKey>
     c76:	83 36       	cpi	r24, 0x63	; 99
     c78:	59 f7       	brne	.-42     	; 0xc50 <task_keypad+0x18>
     c7a:	20 e0       	ldi	r18, 0x00	; 0
     c7c:	40 e0       	ldi	r20, 0x00	; 0
     c7e:	50 e0       	ldi	r21, 0x00	; 0
     c80:	60 e0       	ldi	r22, 0x00	; 0
     c82:	70 e0       	ldi	r23, 0x00	; 0
     c84:	80 91 7f 03 	lds	r24, 0x037F	; 0x80037f <button>
     c88:	90 91 80 03 	lds	r25, 0x0380	; 0x800380 <button+0x1>
     c8c:	0e 94 33 04 	call	0x866	; 0x866 <xQueueGenericSend>
     c90:	0e 94 bc 05 	call	0xb78	; 0xb78 <welcome>
     c94:	0e 94 bc 05 	call	0xb78	; 0xb78 <welcome>
     c98:	0e 94 bc 05 	call	0xb78	; 0xb78 <welcome>
     c9c:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <screen_saver>

00000ca0 <dispaly_integer>:
	}
}


void dispaly_integer (int n, int n_count)
{
     ca0:	ef 92       	push	r14
     ca2:	ff 92       	push	r15
     ca4:	0f 93       	push	r16
     ca6:	1f 93       	push	r17
     ca8:	cf 93       	push	r28
     caa:	df 93       	push	r29
     cac:	cd b7       	in	r28, 0x3d	; 61
     cae:	de b7       	in	r29, 0x3e	; 62
     cb0:	60 97       	sbiw	r28, 0x10	; 16
     cb2:	0f b6       	in	r0, 0x3f	; 63
     cb4:	f8 94       	cli
     cb6:	de bf       	out	0x3e, r29	; 62
     cb8:	0f be       	out	0x3f, r0	; 63
     cba:	cd bf       	out	0x3d, r28	; 61
	unsigned char str[16];
	for(int count = 0 ; count < n_count ; count++)
     cbc:	16 16       	cp	r1, r22
     cbe:	17 06       	cpc	r1, r23
     cc0:	74 f4       	brge	.+28     	; 0xcde <dispaly_integer+0x3e>
     cc2:	8e 01       	movw	r16, r28
     cc4:	0f 5f       	subi	r16, 0xFF	; 255
     cc6:	1f 4f       	sbci	r17, 0xFF	; 255
     cc8:	78 01       	movw	r14, r16
     cca:	e6 0e       	add	r14, r22
     ccc:	f7 1e       	adc	r15, r23
	{
		lcd_displayChar((unsigned char)str[count]);
     cce:	f8 01       	movw	r30, r16
     cd0:	81 91       	ld	r24, Z+
     cd2:	8f 01       	movw	r16, r30
     cd4:	0e 94 84 01 	call	0x308	; 0x308 <lcd_displayChar>


void dispaly_integer (int n, int n_count)
{
	unsigned char str[16];
	for(int count = 0 ; count < n_count ; count++)
     cd8:	0e 15       	cp	r16, r14
     cda:	1f 05       	cpc	r17, r15
     cdc:	c1 f7       	brne	.-16     	; 0xcce <dispaly_integer+0x2e>
	{
		lcd_displayChar((unsigned char)str[count]);
	}

     cde:	60 96       	adiw	r28, 0x10	; 16
     ce0:	0f b6       	in	r0, 0x3f	; 63
     ce2:	f8 94       	cli
     ce4:	de bf       	out	0x3e, r29	; 62
     ce6:	0f be       	out	0x3f, r0	; 63
     ce8:	cd bf       	out	0x3d, r28	; 61
     cea:	df 91       	pop	r29
     cec:	cf 91       	pop	r28
     cee:	1f 91       	pop	r17
     cf0:	0f 91       	pop	r16
     cf2:	ff 90       	pop	r15
     cf4:	ef 90       	pop	r14
     cf6:	08 95       	ret

00000cf8 <calc_operation>:
	static int result=0;
	static int op1_int=0;
	static int op2_int=0;
	static u8 current_position = 0;
	
	if (xSemaphoreTake(button , portMAX_DELAY) == pdTRUE)
     cf8:	20 e0       	ldi	r18, 0x00	; 0
     cfa:	4f ef       	ldi	r20, 0xFF	; 255
     cfc:	5f ef       	ldi	r21, 0xFF	; 255
     cfe:	60 e0       	ldi	r22, 0x00	; 0
     d00:	70 e0       	ldi	r23, 0x00	; 0
     d02:	80 91 7f 03 	lds	r24, 0x037F	; 0x80037f <button>
     d06:	90 91 80 03 	lds	r25, 0x0380	; 0x800380 <button+0x1>
     d0a:	0e 94 cd 04 	call	0x99a	; 0x99a <xQueueGenericReceive>
     d0e:	81 30       	cpi	r24, 0x01	; 1
     d10:	09 f0       	breq	.+2      	; 0xd14 <calc_operation+0x1c>
     d12:	f5 c0       	rjmp	.+490    	; 0xefe <calc_operation+0x206>
	{
		if (button <= '9' && button >= '0')
     d14:	80 91 7f 03 	lds	r24, 0x037F	; 0x80037f <button>
     d18:	90 91 80 03 	lds	r25, 0x0380	; 0x800380 <button+0x1>
     d1c:	9c 01       	movw	r18, r24
     d1e:	20 53       	subi	r18, 0x30	; 48
     d20:	31 09       	sbc	r19, r1
     d22:	2a 30       	cpi	r18, 0x0A	; 10
     d24:	31 05       	cpc	r19, r1
     d26:	60 f5       	brcc	.+88     	; 0xd80 <calc_operation+0x88>
		{
			lcd_gotoxy(0,current_position);
     d28:	60 91 19 03 	lds	r22, 0x0319	; 0x800319 <current_position.2241>
     d2c:	80 e0       	ldi	r24, 0x00	; 0
     d2e:	0e 94 9e 01 	call	0x33c	; 0x33c <lcd_gotoxy>
			current_position++;
     d32:	80 91 19 03 	lds	r24, 0x0319	; 0x800319 <current_position.2241>
     d36:	8f 5f       	subi	r24, 0xFF	; 255
     d38:	80 93 19 03 	sts	0x0319, r24	; 0x800319 <current_position.2241>
			lcd_displayChar(button);
     d3c:	80 91 7f 03 	lds	r24, 0x037F	; 0x80037f <button>
     d40:	0e 94 84 01 	call	0x308	; 0x308 <lcd_displayChar>
			
			if (op1_complete == 0)
     d44:	80 91 18 03 	lds	r24, 0x0318	; 0x800318 <op1_complete.2237>
     d48:	81 11       	cpse	r24, r1
     d4a:	0d c0       	rjmp	.+26     	; 0xd66 <calc_operation+0x6e>
			{
				op1[op1_count]=button;
     d4c:	80 91 17 03 	lds	r24, 0x0317	; 0x800317 <op1_count.2233>
     d50:	e8 2f       	mov	r30, r24
     d52:	f0 e0       	ldi	r31, 0x00	; 0
     d54:	e9 5f       	subi	r30, 0xF9	; 249
     d56:	fc 4f       	sbci	r31, 0xFC	; 252
     d58:	90 91 7f 03 	lds	r25, 0x037F	; 0x80037f <button>
     d5c:	90 83       	st	Z, r25
				op1_count++;
     d5e:	8f 5f       	subi	r24, 0xFF	; 255
     d60:	80 93 17 03 	sts	0x0317, r24	; 0x800317 <op1_count.2233>
     d64:	08 95       	ret
				
			}
			else
			{
				op2[op2_count]=button;
     d66:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <op2_count.2235>
     d6a:	e8 2f       	mov	r30, r24
     d6c:	f0 e0       	ldi	r31, 0x00	; 0
     d6e:	ea 50       	subi	r30, 0x0A	; 10
     d70:	fd 4f       	sbci	r31, 0xFD	; 253
     d72:	90 91 7f 03 	lds	r25, 0x037F	; 0x80037f <button>
     d76:	90 83       	st	Z, r25
				op2_count++;
     d78:	8f 5f       	subi	r24, 0xFF	; 255
     d7a:	80 93 06 03 	sts	0x0306, r24	; 0x800306 <op2_count.2235>
     d7e:	08 95       	ret
			}
		}
		else
		{
			if (button == '=')
     d80:	8d 33       	cpi	r24, 0x3D	; 61
     d82:	91 05       	cpc	r25, r1
     d84:	09 f0       	breq	.+2      	; 0xd88 <calc_operation+0x90>
     d86:	90 c0       	rjmp	.+288    	; 0xea8 <calc_operation+0x1b0>
			{
				op1_int = atoi(op1);
     d88:	87 e0       	ldi	r24, 0x07	; 7
     d8a:	93 e0       	ldi	r25, 0x03	; 3
     d8c:	0e 94 66 0c 	call	0x18cc	; 0x18cc <atoi>
     d90:	90 93 f5 02 	sts	0x02F5, r25	; 0x8002f5 <op1_int.2239+0x1>
     d94:	80 93 f4 02 	sts	0x02F4, r24	; 0x8002f4 <op1_int.2239>
				op2_int = atoi(op2);
     d98:	86 ef       	ldi	r24, 0xF6	; 246
     d9a:	92 e0       	ldi	r25, 0x02	; 2
     d9c:	0e 94 66 0c 	call	0x18cc	; 0x18cc <atoi>
     da0:	bc 01       	movw	r22, r24
				switch (equation_op)
     da2:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     da6:	8b 32       	cpi	r24, 0x2B	; 43
     da8:	49 f0       	breq	.+18     	; 0xdbc <calc_operation+0xc4>
     daa:	18 f4       	brcc	.+6      	; 0xdb2 <calc_operation+0xba>
     dac:	8a 32       	cpi	r24, 0x2A	; 42
     dae:	e1 f0       	breq	.+56     	; 0xde8 <calc_operation+0xf0>
     db0:	61 c0       	rjmp	.+194    	; 0xe74 <calc_operation+0x17c>
     db2:	8d 32       	cpi	r24, 0x2D	; 45
     db4:	71 f0       	breq	.+28     	; 0xdd2 <calc_operation+0xda>
     db6:	8f 32       	cpi	r24, 0x2F	; 47
     db8:	39 f1       	breq	.+78     	; 0xe08 <calc_operation+0x110>
     dba:	5c c0       	rjmp	.+184    	; 0xe74 <calc_operation+0x17c>
				{
					case '+':
					result = op1_int+op2_int;
     dbc:	80 91 f4 02 	lds	r24, 0x02F4	; 0x8002f4 <op1_int.2239>
     dc0:	90 91 f5 02 	lds	r25, 0x02F5	; 0x8002f5 <op1_int.2239+0x1>
     dc4:	68 0f       	add	r22, r24
     dc6:	79 1f       	adc	r23, r25
     dc8:	70 93 f3 02 	sts	0x02F3, r23	; 0x8002f3 <result.2238+0x1>
     dcc:	60 93 f2 02 	sts	0x02F2, r22	; 0x8002f2 <result.2238>
					break;
     dd0:	51 c0       	rjmp	.+162    	; 0xe74 <calc_operation+0x17c>
					case '-':
					result = op1_int-op2_int;
     dd2:	80 91 f4 02 	lds	r24, 0x02F4	; 0x8002f4 <op1_int.2239>
     dd6:	90 91 f5 02 	lds	r25, 0x02F5	; 0x8002f5 <op1_int.2239+0x1>
     dda:	86 1b       	sub	r24, r22
     ddc:	97 0b       	sbc	r25, r23
     dde:	90 93 f3 02 	sts	0x02F3, r25	; 0x8002f3 <result.2238+0x1>
     de2:	80 93 f2 02 	sts	0x02F2, r24	; 0x8002f2 <result.2238>
					break;
     de6:	46 c0       	rjmp	.+140    	; 0xe74 <calc_operation+0x17c>
					case '*':
					result = op1_int*op2_int;
     de8:	20 91 f4 02 	lds	r18, 0x02F4	; 0x8002f4 <op1_int.2239>
     dec:	30 91 f5 02 	lds	r19, 0x02F5	; 0x8002f5 <op1_int.2239+0x1>
     df0:	26 9f       	mul	r18, r22
     df2:	c0 01       	movw	r24, r0
     df4:	27 9f       	mul	r18, r23
     df6:	90 0d       	add	r25, r0
     df8:	36 9f       	mul	r19, r22
     dfa:	90 0d       	add	r25, r0
     dfc:	11 24       	eor	r1, r1
     dfe:	90 93 f3 02 	sts	0x02F3, r25	; 0x8002f3 <result.2238+0x1>
     e02:	80 93 f2 02 	sts	0x02F2, r24	; 0x8002f2 <result.2238>
					break;
     e06:	36 c0       	rjmp	.+108    	; 0xe74 <calc_operation+0x17c>
					case '/':
					if(op2_int == 0)
     e08:	61 15       	cp	r22, r1
     e0a:	71 05       	cpc	r23, r1
     e0c:	49 f5       	brne	.+82     	; 0xe60 <calc_operation+0x168>
					{
						lcd_disp_string_xy("Math Error",0,0);
     e0e:	40 e0       	ldi	r20, 0x00	; 0
     e10:	50 e0       	ldi	r21, 0x00	; 0
     e12:	60 e0       	ldi	r22, 0x00	; 0
     e14:	70 e0       	ldi	r23, 0x00	; 0
     e16:	85 e8       	ldi	r24, 0x85	; 133
     e18:	90 e0       	ldi	r25, 0x00	; 0
     e1a:	0e 94 c9 01 	call	0x392	; 0x392 <lcd_disp_string_xy>
						vTaskDelay(500);
     e1e:	84 ef       	ldi	r24, 0xF4	; 244
     e20:	91 e0       	ldi	r25, 0x01	; 1
     e22:	0e 94 d2 0a 	call	0x15a4	; 0x15a4 <vTaskDelay>
						lcd_clrScreen();
     e26:	0e 94 b6 01 	call	0x36c	; 0x36c <lcd_clrScreen>
						lcd_displayChar('0');
     e2a:	80 e3       	ldi	r24, 0x30	; 48
     e2c:	0e 94 84 01 	call	0x308	; 0x308 <lcd_displayChar>
						current_position =0;
     e30:	10 92 19 03 	sts	0x0319, r1	; 0x800319 <current_position.2241>
						op1_complete = 0;
     e34:	10 92 18 03 	sts	0x0318, r1	; 0x800318 <op1_complete.2237>
						op1_count = 0;
     e38:	10 92 17 03 	sts	0x0317, r1	; 0x800317 <op1_count.2233>
     e3c:	e7 e0       	ldi	r30, 0x07	; 7
     e3e:	f3 e0       	ldi	r31, 0x03	; 3
     e40:	a6 ef       	ldi	r26, 0xF6	; 246
     e42:	b2 e0       	ldi	r27, 0x02	; 2
     e44:	87 e1       	ldi	r24, 0x17	; 23
     e46:	93 e0       	ldi	r25, 0x03	; 3
						for (int i = 0 ; i< 16 ; i++)
						{
							op1[i] = 0;
     e48:	11 92       	st	Z+, r1
							op2[i] = 0;
     e4a:	1d 92       	st	X+, r1
						lcd_clrScreen();
						lcd_displayChar('0');
						current_position =0;
						op1_complete = 0;
						op1_count = 0;
						for (int i = 0 ; i< 16 ; i++)
     e4c:	e8 17       	cp	r30, r24
     e4e:	f9 07       	cpc	r31, r25
     e50:	d9 f7       	brne	.-10     	; 0xe48 <calc_operation+0x150>
						{
							op1[i] = 0;
							op2[i] = 0;
						}
						op2_count =0;
     e52:	10 92 06 03 	sts	0x0306, r1	; 0x800306 <op2_count.2235>
						result = 0;
     e56:	10 92 f3 02 	sts	0x02F3, r1	; 0x8002f3 <result.2238+0x1>
     e5a:	10 92 f2 02 	sts	0x02F2, r1	; 0x8002f2 <result.2238>
     e5e:	0a c0       	rjmp	.+20     	; 0xe74 <calc_operation+0x17c>
					}
					else
					result = op1_int/op2_int;
     e60:	80 91 f4 02 	lds	r24, 0x02F4	; 0x8002f4 <op1_int.2239>
     e64:	90 91 f5 02 	lds	r25, 0x02F5	; 0x8002f5 <op1_int.2239+0x1>
     e68:	0e 94 38 0c 	call	0x1870	; 0x1870 <__divmodhi4>
     e6c:	70 93 f3 02 	sts	0x02F3, r23	; 0x8002f3 <result.2238+0x1>
     e70:	60 93 f2 02 	sts	0x02F2, r22	; 0x8002f2 <result.2238>
					break;
				}
				
				lcd_clrScreen();
     e74:	0e 94 b6 01 	call	0x36c	; 0x36c <lcd_clrScreen>
				dispaly_integer(result,op1_count+op2_count);
     e78:	80 91 17 03 	lds	r24, 0x0317	; 0x800317 <op1_count.2233>
     e7c:	60 91 06 03 	lds	r22, 0x0306	; 0x800306 <op2_count.2235>
     e80:	70 e0       	ldi	r23, 0x00	; 0
     e82:	68 0f       	add	r22, r24
     e84:	71 1d       	adc	r23, r1
     e86:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <result.2238>
     e8a:	90 91 f3 02 	lds	r25, 0x02F3	; 0x8002f3 <result.2238+0x1>
     e8e:	0e 94 50 06 	call	0xca0	; 0xca0 <dispaly_integer>
     e92:	e6 ef       	ldi	r30, 0xF6	; 246
     e94:	f2 e0       	ldi	r31, 0x02	; 2
     e96:	86 e0       	ldi	r24, 0x06	; 6
     e98:	93 e0       	ldi	r25, 0x03	; 3
				
				for (int i = 0 ; i< 16 ; i++)
				{
					op2[i] = 0;
     e9a:	11 92       	st	Z+, r1
				}
				
				lcd_clrScreen();
				dispaly_integer(result,op1_count+op2_count);
				
				for (int i = 0 ; i< 16 ; i++)
     e9c:	8e 17       	cp	r24, r30
     e9e:	9f 07       	cpc	r25, r31
     ea0:	e1 f7       	brne	.-8      	; 0xe9a <calc_operation+0x1a2>
				{
					op2[i] = 0;
				}
				op2_count =0;
     ea2:	10 92 06 03 	sts	0x0306, r1	; 0x800306 <op2_count.2235>
     ea6:	08 95       	ret
			}
			else if (button == 'C')
     ea8:	83 34       	cpi	r24, 0x43	; 67
     eaa:	91 05       	cpc	r25, r1
     eac:	e9 f4       	brne	.+58     	; 0xee8 <calc_operation+0x1f0>
			{
				lcd_clrScreen();
     eae:	0e 94 b6 01 	call	0x36c	; 0x36c <lcd_clrScreen>
				
				lcd_displayChar('0');
     eb2:	80 e3       	ldi	r24, 0x30	; 48
     eb4:	0e 94 84 01 	call	0x308	; 0x308 <lcd_displayChar>
				current_position =0;
     eb8:	10 92 19 03 	sts	0x0319, r1	; 0x800319 <current_position.2241>
				op1_complete = 0;
     ebc:	10 92 18 03 	sts	0x0318, r1	; 0x800318 <op1_complete.2237>
				op1_count = 0;
     ec0:	10 92 17 03 	sts	0x0317, r1	; 0x800317 <op1_count.2233>
     ec4:	e7 e0       	ldi	r30, 0x07	; 7
     ec6:	f3 e0       	ldi	r31, 0x03	; 3
     ec8:	a6 ef       	ldi	r26, 0xF6	; 246
     eca:	b2 e0       	ldi	r27, 0x02	; 2
     ecc:	87 e1       	ldi	r24, 0x17	; 23
     ece:	93 e0       	ldi	r25, 0x03	; 3
				for (int i = 0 ; i< 16 ; i++)
				{
					op1[i] = 0;
     ed0:	11 92       	st	Z+, r1
					op2[i] = 0;
     ed2:	1d 92       	st	X+, r1
				
				lcd_displayChar('0');
				current_position =0;
				op1_complete = 0;
				op1_count = 0;
				for (int i = 0 ; i< 16 ; i++)
     ed4:	e8 17       	cp	r30, r24
     ed6:	f9 07       	cpc	r31, r25
     ed8:	d9 f7       	brne	.-10     	; 0xed0 <calc_operation+0x1d8>
				{
					op1[i] = 0;
					op2[i] = 0;
				}
				op2_count =0;
     eda:	10 92 06 03 	sts	0x0306, r1	; 0x800306 <op2_count.2235>
				result = 0;
     ede:	10 92 f3 02 	sts	0x02F3, r1	; 0x8002f3 <result.2238+0x1>
     ee2:	10 92 f2 02 	sts	0x02F2, r1	; 0x8002f2 <result.2238>
     ee6:	08 95       	ret
			}
			else
			{
				lcd_clrScreen();
     ee8:	0e 94 b6 01 	call	0x36c	; 0x36c <lcd_clrScreen>
				current_position=0;
     eec:	10 92 19 03 	sts	0x0319, r1	; 0x800319 <current_position.2241>
				equation_op = button;
     ef0:	80 91 7f 03 	lds	r24, 0x037F	; 0x80037f <button>
     ef4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
				op1_complete =1;
     ef8:	81 e0       	ldi	r24, 0x01	; 1
     efa:	80 93 18 03 	sts	0x0318, r24	; 0x800318 <op1_complete.2237>
     efe:	08 95       	ret

00000f00 <task_lcd>:
	return 0;
}


void task_lcd(void* p)
{
     f00:	cf 93       	push	r28
     f02:	df 93       	push	r29
     f04:	00 d0       	rcall	.+0      	; 0xf06 <task_lcd+0x6>
     f06:	cd b7       	in	r28, 0x3d	; 61
     f08:	de b7       	in	r29, 0x3e	; 62
	portTickType x;
	x = xTaskGetTickCount();
     f0a:	0e 94 35 09 	call	0x126a	; 0x126a <xTaskGetTickCount>
     f0e:	9a 83       	std	Y+2, r25	; 0x02
     f10:	89 83       	std	Y+1, r24	; 0x01
	for(;;)
	{
		vTaskDelayUntil(&x,100);
     f12:	64 e6       	ldi	r22, 0x64	; 100
     f14:	70 e0       	ldi	r23, 0x00	; 0
     f16:	ce 01       	movw	r24, r28
     f18:	01 96       	adiw	r24, 0x01	; 1
     f1a:	0e 94 88 0a 	call	0x1510	; 0x1510 <vTaskDelayUntil>
		if(xSemaphoreTake(lcd_data,portMAX_DELAY) == pdTRUE)
     f1e:	20 e0       	ldi	r18, 0x00	; 0
     f20:	4f ef       	ldi	r20, 0xFF	; 255
     f22:	5f ef       	ldi	r21, 0xFF	; 255
     f24:	60 e0       	ldi	r22, 0x00	; 0
     f26:	70 e0       	ldi	r23, 0x00	; 0
     f28:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <lcd_data>
     f2c:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <lcd_data+0x1>
     f30:	0e 94 cd 04 	call	0x99a	; 0x99a <xQueueGenericReceive>
     f34:	81 30       	cpi	r24, 0x01	; 1
     f36:	69 f7       	brne	.-38     	; 0xf12 <task_lcd+0x12>
		{
			if (button == "C")
     f38:	80 91 7f 03 	lds	r24, 0x037F	; 0x80037f <button>
     f3c:	90 91 80 03 	lds	r25, 0x0380	; 0x800380 <button+0x1>
     f40:	80 59       	subi	r24, 0x90	; 144
     f42:	90 40       	sbci	r25, 0x00	; 0
     f44:	31 f7       	brne	.-52     	; 0xf12 <task_lcd+0x12>
				break;
		}
	}
	for(;;)
	{
		vTaskDelayUntil(&x,100);
     f46:	64 e6       	ldi	r22, 0x64	; 100
     f48:	70 e0       	ldi	r23, 0x00	; 0
     f4a:	ce 01       	movw	r24, r28
     f4c:	01 96       	adiw	r24, 0x01	; 1
     f4e:	0e 94 88 0a 	call	0x1510	; 0x1510 <vTaskDelayUntil>
		if(xSemaphoreTake(lcd_data,portMAX_DELAY) == pdTRUE)
     f52:	20 e0       	ldi	r18, 0x00	; 0
     f54:	4f ef       	ldi	r20, 0xFF	; 255
     f56:	5f ef       	ldi	r21, 0xFF	; 255
     f58:	60 e0       	ldi	r22, 0x00	; 0
     f5a:	70 e0       	ldi	r23, 0x00	; 0
     f5c:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <lcd_data>
     f60:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <lcd_data+0x1>
     f64:	0e 94 cd 04 	call	0x99a	; 0x99a <xQueueGenericReceive>
     f68:	81 30       	cpi	r24, 0x01	; 1
     f6a:	69 f7       	brne	.-38     	; 0xf46 <task_lcd+0x46>
		{
			calc_operation();
     f6c:	0e 94 7c 06 	call	0xcf8	; 0xcf8 <calc_operation>
			xSemaphoreGive(lcd_data);
     f70:	20 e0       	ldi	r18, 0x00	; 0
     f72:	40 e0       	ldi	r20, 0x00	; 0
     f74:	50 e0       	ldi	r21, 0x00	; 0
     f76:	60 e0       	ldi	r22, 0x00	; 0
     f78:	70 e0       	ldi	r23, 0x00	; 0
     f7a:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <lcd_data>
     f7e:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <lcd_data+0x1>
     f82:	0e 94 33 04 	call	0x866	; 0x866 <xQueueGenericSend>
     f86:	df cf       	rjmp	.-66     	; 0xf46 <task_lcd+0x46>

00000f88 <prvAddCurrentTaskToDelayedList>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
     f88:	cf 93       	push	r28
     f8a:	df 93       	push	r29
     f8c:	ec 01       	movw	r28, r24
     f8e:	e0 91 7b 03 	lds	r30, 0x037B	; 0x80037b <pxCurrentTCB>
     f92:	f0 91 7c 03 	lds	r31, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
     f96:	93 83       	std	Z+3, r25	; 0x03
     f98:	82 83       	std	Z+2, r24	; 0x02
     f9a:	80 91 22 03 	lds	r24, 0x0322	; 0x800322 <xTickCount>
     f9e:	90 91 23 03 	lds	r25, 0x0323	; 0x800323 <xTickCount+0x1>
     fa2:	c8 17       	cp	r28, r24
     fa4:	d9 07       	cpc	r29, r25
     fa6:	68 f4       	brcc	.+26     	; 0xfc2 <prvAddCurrentTaskToDelayedList+0x3a>
     fa8:	60 91 7b 03 	lds	r22, 0x037B	; 0x80037b <pxCurrentTCB>
     fac:	70 91 7c 03 	lds	r23, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
     fb0:	80 91 38 03 	lds	r24, 0x0338	; 0x800338 <pxOverflowDelayedTaskList>
     fb4:	90 91 39 03 	lds	r25, 0x0339	; 0x800339 <pxOverflowDelayedTaskList+0x1>
     fb8:	6e 5f       	subi	r22, 0xFE	; 254
     fba:	7f 4f       	sbci	r23, 0xFF	; 255
     fbc:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInsert>
     fc0:	17 c0       	rjmp	.+46     	; 0xff0 <prvAddCurrentTaskToDelayedList+0x68>
     fc2:	60 91 7b 03 	lds	r22, 0x037B	; 0x80037b <pxCurrentTCB>
     fc6:	70 91 7c 03 	lds	r23, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
     fca:	80 91 3a 03 	lds	r24, 0x033A	; 0x80033a <pxDelayedTaskList>
     fce:	90 91 3b 03 	lds	r25, 0x033B	; 0x80033b <pxDelayedTaskList+0x1>
     fd2:	6e 5f       	subi	r22, 0xFE	; 254
     fd4:	7f 4f       	sbci	r23, 0xFF	; 255
     fd6:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInsert>
     fda:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <xNextTaskUnblockTime>
     fde:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <xNextTaskUnblockTime+0x1>
     fe2:	c8 17       	cp	r28, r24
     fe4:	d9 07       	cpc	r29, r25
     fe6:	20 f4       	brcc	.+8      	; 0xff0 <prvAddCurrentTaskToDelayedList+0x68>
     fe8:	d0 93 62 00 	sts	0x0062, r29	; 0x800062 <xNextTaskUnblockTime+0x1>
     fec:	c0 93 61 00 	sts	0x0061, r28	; 0x800061 <xNextTaskUnblockTime>
     ff0:	df 91       	pop	r29
     ff2:	cf 91       	pop	r28
     ff4:	08 95       	ret

00000ff6 <xTaskGenericCreate>:
     ff6:	4f 92       	push	r4
     ff8:	5f 92       	push	r5
     ffa:	6f 92       	push	r6
     ffc:	7f 92       	push	r7
     ffe:	8f 92       	push	r8
    1000:	9f 92       	push	r9
    1002:	af 92       	push	r10
    1004:	bf 92       	push	r11
    1006:	cf 92       	push	r12
    1008:	df 92       	push	r13
    100a:	ef 92       	push	r14
    100c:	ff 92       	push	r15
    100e:	0f 93       	push	r16
    1010:	1f 93       	push	r17
    1012:	cf 93       	push	r28
    1014:	df 93       	push	r29
    1016:	5c 01       	movw	r10, r24
    1018:	4b 01       	movw	r8, r22
    101a:	ea 01       	movw	r28, r20
    101c:	29 01       	movw	r4, r18
    101e:	81 e2       	ldi	r24, 0x21	; 33
    1020:	90 e0       	ldi	r25, 0x00	; 0
    1022:	0e 94 a7 00 	call	0x14e	; 0x14e <pvPortMalloc>
    1026:	3c 01       	movw	r6, r24
    1028:	00 97       	sbiw	r24, 0x00	; 0
    102a:	09 f4       	brne	.+2      	; 0x102e <xTaskGenericCreate+0x38>
    102c:	db c0       	rjmp	.+438    	; 0x11e4 <xTaskGenericCreate+0x1ee>
    102e:	c1 14       	cp	r12, r1
    1030:	d1 04       	cpc	r13, r1
    1032:	09 f0       	breq	.+2      	; 0x1036 <xTaskGenericCreate+0x40>
    1034:	d2 c0       	rjmp	.+420    	; 0x11da <xTaskGenericCreate+0x1e4>
    1036:	ce 01       	movw	r24, r28
    1038:	0e 94 a7 00 	call	0x14e	; 0x14e <pvPortMalloc>
    103c:	f3 01       	movw	r30, r6
    103e:	90 8f       	std	Z+24, r25	; 0x18
    1040:	87 8b       	std	Z+23, r24	; 0x17
    1042:	00 97       	sbiw	r24, 0x00	; 0
    1044:	21 f4       	brne	.+8      	; 0x104e <xTaskGenericCreate+0x58>
    1046:	c3 01       	movw	r24, r6
    1048:	0e 94 cd 00 	call	0x19a	; 0x19a <vPortFree>
    104c:	cb c0       	rjmp	.+406    	; 0x11e4 <xTaskGenericCreate+0x1ee>
    104e:	ae 01       	movw	r20, r28
    1050:	65 ea       	ldi	r22, 0xA5	; 165
    1052:	70 e0       	ldi	r23, 0x00	; 0
    1054:	0e 94 8d 0c 	call	0x191a	; 0x191a <memset>
    1058:	21 97       	sbiw	r28, 0x01	; 1
    105a:	f3 01       	movw	r30, r6
    105c:	87 89       	ldd	r24, Z+23	; 0x17
    105e:	90 8d       	ldd	r25, Z+24	; 0x18
    1060:	c8 0f       	add	r28, r24
    1062:	d9 1f       	adc	r29, r25
    1064:	48 e0       	ldi	r20, 0x08	; 8
    1066:	50 e0       	ldi	r21, 0x00	; 0
    1068:	b4 01       	movw	r22, r8
    106a:	c3 01       	movw	r24, r6
    106c:	49 96       	adiw	r24, 0x19	; 25
    106e:	0e 94 94 0c 	call	0x1928	; 0x1928 <strncpy>
    1072:	f3 01       	movw	r30, r6
    1074:	10 a2       	std	Z+32, r1	; 0x20
    1076:	10 2f       	mov	r17, r16
    1078:	05 30       	cpi	r16, 0x05	; 5
    107a:	08 f0       	brcs	.+2      	; 0x107e <xTaskGenericCreate+0x88>
    107c:	14 e0       	ldi	r17, 0x04	; 4
    107e:	f3 01       	movw	r30, r6
    1080:	16 8b       	std	Z+22, r17	; 0x16
    1082:	63 01       	movw	r12, r6
    1084:	f2 e0       	ldi	r31, 0x02	; 2
    1086:	cf 0e       	add	r12, r31
    1088:	d1 1c       	adc	r13, r1
    108a:	c6 01       	movw	r24, r12
    108c:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <vListInitialiseItem>
    1090:	c3 01       	movw	r24, r6
    1092:	0c 96       	adiw	r24, 0x0c	; 12
    1094:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <vListInitialiseItem>
    1098:	f3 01       	movw	r30, r6
    109a:	71 86       	std	Z+9, r7	; 0x09
    109c:	60 86       	std	Z+8, r6	; 0x08
    109e:	85 e0       	ldi	r24, 0x05	; 5
    10a0:	90 e0       	ldi	r25, 0x00	; 0
    10a2:	81 1b       	sub	r24, r17
    10a4:	91 09       	sbc	r25, r1
    10a6:	95 87       	std	Z+13, r25	; 0x0d
    10a8:	84 87       	std	Z+12, r24	; 0x0c
    10aa:	73 8a       	std	Z+19, r7	; 0x13
    10ac:	62 8a       	std	Z+18, r6	; 0x12
    10ae:	a2 01       	movw	r20, r4
    10b0:	b5 01       	movw	r22, r10
    10b2:	ce 01       	movw	r24, r28
    10b4:	0e 94 70 02 	call	0x4e0	; 0x4e0 <pxPortInitialiseStack>
    10b8:	f3 01       	movw	r30, r6
    10ba:	91 83       	std	Z+1, r25	; 0x01
    10bc:	80 83       	st	Z, r24
    10be:	e1 14       	cp	r14, r1
    10c0:	f1 04       	cpc	r15, r1
    10c2:	19 f0       	breq	.+6      	; 0x10ca <xTaskGenericCreate+0xd4>
    10c4:	f7 01       	movw	r30, r14
    10c6:	71 82       	std	Z+1, r7	; 0x01
    10c8:	60 82       	st	Z, r6
    10ca:	0f b6       	in	r0, 0x3f	; 63
    10cc:	f8 94       	cli
    10ce:	0f 92       	push	r0
    10d0:	80 91 24 03 	lds	r24, 0x0324	; 0x800324 <uxCurrentNumberOfTasks>
    10d4:	8f 5f       	subi	r24, 0xFF	; 255
    10d6:	80 93 24 03 	sts	0x0324, r24	; 0x800324 <uxCurrentNumberOfTasks>
    10da:	80 91 7b 03 	lds	r24, 0x037B	; 0x80037b <pxCurrentTCB>
    10de:	90 91 7c 03 	lds	r25, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
    10e2:	89 2b       	or	r24, r25
    10e4:	a1 f5       	brne	.+104    	; 0x114e <xTaskGenericCreate+0x158>
    10e6:	70 92 7c 03 	sts	0x037C, r7	; 0x80037c <pxCurrentTCB+0x1>
    10ea:	60 92 7b 03 	sts	0x037B, r6	; 0x80037b <pxCurrentTCB>
    10ee:	80 91 24 03 	lds	r24, 0x0324	; 0x800324 <uxCurrentNumberOfTasks>
    10f2:	81 30       	cpi	r24, 0x01	; 1
    10f4:	d9 f5       	brne	.+118    	; 0x116c <xTaskGenericCreate+0x176>
    10f6:	ce e4       	ldi	r28, 0x4E	; 78
    10f8:	d3 e0       	ldi	r29, 0x03	; 3
    10fa:	0f 2e       	mov	r0, r31
    10fc:	fb e7       	ldi	r31, 0x7B	; 123
    10fe:	ef 2e       	mov	r14, r31
    1100:	f3 e0       	ldi	r31, 0x03	; 3
    1102:	ff 2e       	mov	r15, r31
    1104:	f0 2d       	mov	r31, r0
    1106:	ce 01       	movw	r24, r28
    1108:	0e 94 d6 01 	call	0x3ac	; 0x3ac <vListInitialise>
    110c:	29 96       	adiw	r28, 0x09	; 9
    110e:	ce 15       	cp	r28, r14
    1110:	df 05       	cpc	r29, r15
    1112:	c9 f7       	brne	.-14     	; 0x1106 <xTaskGenericCreate+0x110>
    1114:	85 e4       	ldi	r24, 0x45	; 69
    1116:	93 e0       	ldi	r25, 0x03	; 3
    1118:	0e 94 d6 01 	call	0x3ac	; 0x3ac <vListInitialise>
    111c:	8c e3       	ldi	r24, 0x3C	; 60
    111e:	93 e0       	ldi	r25, 0x03	; 3
    1120:	0e 94 d6 01 	call	0x3ac	; 0x3ac <vListInitialise>
    1124:	8f e2       	ldi	r24, 0x2F	; 47
    1126:	93 e0       	ldi	r25, 0x03	; 3
    1128:	0e 94 d6 01 	call	0x3ac	; 0x3ac <vListInitialise>
    112c:	86 e2       	ldi	r24, 0x26	; 38
    112e:	93 e0       	ldi	r25, 0x03	; 3
    1130:	0e 94 d6 01 	call	0x3ac	; 0x3ac <vListInitialise>
    1134:	85 e4       	ldi	r24, 0x45	; 69
    1136:	93 e0       	ldi	r25, 0x03	; 3
    1138:	90 93 3b 03 	sts	0x033B, r25	; 0x80033b <pxDelayedTaskList+0x1>
    113c:	80 93 3a 03 	sts	0x033A, r24	; 0x80033a <pxDelayedTaskList>
    1140:	8c e3       	ldi	r24, 0x3C	; 60
    1142:	93 e0       	ldi	r25, 0x03	; 3
    1144:	90 93 39 03 	sts	0x0339, r25	; 0x800339 <pxOverflowDelayedTaskList+0x1>
    1148:	80 93 38 03 	sts	0x0338, r24	; 0x800338 <pxOverflowDelayedTaskList>
    114c:	0f c0       	rjmp	.+30     	; 0x116c <xTaskGenericCreate+0x176>
    114e:	80 91 1f 03 	lds	r24, 0x031F	; 0x80031f <xSchedulerRunning>
    1152:	81 11       	cpse	r24, r1
    1154:	0b c0       	rjmp	.+22     	; 0x116c <xTaskGenericCreate+0x176>
    1156:	e0 91 7b 03 	lds	r30, 0x037B	; 0x80037b <pxCurrentTCB>
    115a:	f0 91 7c 03 	lds	r31, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
    115e:	86 89       	ldd	r24, Z+22	; 0x16
    1160:	08 17       	cp	r16, r24
    1162:	20 f0       	brcs	.+8      	; 0x116c <xTaskGenericCreate+0x176>
    1164:	70 92 7c 03 	sts	0x037C, r7	; 0x80037c <pxCurrentTCB+0x1>
    1168:	60 92 7b 03 	sts	0x037B, r6	; 0x80037b <pxCurrentTCB>
    116c:	f3 01       	movw	r30, r6
    116e:	86 89       	ldd	r24, Z+22	; 0x16
    1170:	90 91 21 03 	lds	r25, 0x0321	; 0x800321 <uxTopUsedPriority>
    1174:	98 17       	cp	r25, r24
    1176:	10 f4       	brcc	.+4      	; 0x117c <xTaskGenericCreate+0x186>
    1178:	80 93 21 03 	sts	0x0321, r24	; 0x800321 <uxTopUsedPriority>
    117c:	90 91 1a 03 	lds	r25, 0x031A	; 0x80031a <uxTaskNumber>
    1180:	9f 5f       	subi	r25, 0xFF	; 255
    1182:	90 93 1a 03 	sts	0x031A, r25	; 0x80031a <uxTaskNumber>
    1186:	90 91 20 03 	lds	r25, 0x0320	; 0x800320 <uxTopReadyPriority>
    118a:	98 17       	cp	r25, r24
    118c:	10 f4       	brcc	.+4      	; 0x1192 <xTaskGenericCreate+0x19c>
    118e:	80 93 20 03 	sts	0x0320, r24	; 0x800320 <uxTopReadyPriority>
    1192:	90 e0       	ldi	r25, 0x00	; 0
    1194:	9c 01       	movw	r18, r24
    1196:	22 0f       	add	r18, r18
    1198:	33 1f       	adc	r19, r19
    119a:	22 0f       	add	r18, r18
    119c:	33 1f       	adc	r19, r19
    119e:	22 0f       	add	r18, r18
    11a0:	33 1f       	adc	r19, r19
    11a2:	82 0f       	add	r24, r18
    11a4:	93 1f       	adc	r25, r19
    11a6:	b6 01       	movw	r22, r12
    11a8:	82 5b       	subi	r24, 0xB2	; 178
    11aa:	9c 4f       	sbci	r25, 0xFC	; 252
    11ac:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <vListInsertEnd>
    11b0:	0f 90       	pop	r0
    11b2:	0f be       	out	0x3f, r0	; 63
    11b4:	80 91 1f 03 	lds	r24, 0x031F	; 0x80031f <xSchedulerRunning>
    11b8:	88 23       	and	r24, r24
    11ba:	59 f0       	breq	.+22     	; 0x11d2 <xTaskGenericCreate+0x1dc>
    11bc:	e0 91 7b 03 	lds	r30, 0x037B	; 0x80037b <pxCurrentTCB>
    11c0:	f0 91 7c 03 	lds	r31, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
    11c4:	86 89       	ldd	r24, Z+22	; 0x16
    11c6:	80 17       	cp	r24, r16
    11c8:	30 f4       	brcc	.+12     	; 0x11d6 <xTaskGenericCreate+0x1e0>
    11ca:	0e 94 11 03 	call	0x622	; 0x622 <vPortYield>
    11ce:	81 e0       	ldi	r24, 0x01	; 1
    11d0:	0a c0       	rjmp	.+20     	; 0x11e6 <xTaskGenericCreate+0x1f0>
    11d2:	81 e0       	ldi	r24, 0x01	; 1
    11d4:	08 c0       	rjmp	.+16     	; 0x11e6 <xTaskGenericCreate+0x1f0>
    11d6:	81 e0       	ldi	r24, 0x01	; 1
    11d8:	06 c0       	rjmp	.+12     	; 0x11e6 <xTaskGenericCreate+0x1f0>
    11da:	fc 01       	movw	r30, r24
    11dc:	d0 8e       	std	Z+24, r13	; 0x18
    11de:	c7 8a       	std	Z+23, r12	; 0x17
    11e0:	c6 01       	movw	r24, r12
    11e2:	35 cf       	rjmp	.-406    	; 0x104e <xTaskGenericCreate+0x58>
    11e4:	8f ef       	ldi	r24, 0xFF	; 255
    11e6:	df 91       	pop	r29
    11e8:	cf 91       	pop	r28
    11ea:	1f 91       	pop	r17
    11ec:	0f 91       	pop	r16
    11ee:	ff 90       	pop	r15
    11f0:	ef 90       	pop	r14
    11f2:	df 90       	pop	r13
    11f4:	cf 90       	pop	r12
    11f6:	bf 90       	pop	r11
    11f8:	af 90       	pop	r10
    11fa:	9f 90       	pop	r9
    11fc:	8f 90       	pop	r8
    11fe:	7f 90       	pop	r7
    1200:	6f 90       	pop	r6
    1202:	5f 90       	pop	r5
    1204:	4f 90       	pop	r4
    1206:	08 95       	ret

00001208 <vTaskStartScheduler>:
    1208:	af 92       	push	r10
    120a:	bf 92       	push	r11
    120c:	cf 92       	push	r12
    120e:	df 92       	push	r13
    1210:	ef 92       	push	r14
    1212:	ff 92       	push	r15
    1214:	0f 93       	push	r16
    1216:	a1 2c       	mov	r10, r1
    1218:	b1 2c       	mov	r11, r1
    121a:	c1 2c       	mov	r12, r1
    121c:	d1 2c       	mov	r13, r1
    121e:	e1 2c       	mov	r14, r1
    1220:	f1 2c       	mov	r15, r1
    1222:	00 e0       	ldi	r16, 0x00	; 0
    1224:	20 e0       	ldi	r18, 0x00	; 0
    1226:	30 e0       	ldi	r19, 0x00	; 0
    1228:	45 e5       	ldi	r20, 0x55	; 85
    122a:	50 e0       	ldi	r21, 0x00	; 0
    122c:	62 e9       	ldi	r22, 0x92	; 146
    122e:	70 e0       	ldi	r23, 0x00	; 0
    1230:	82 ef       	ldi	r24, 0xF2	; 242
    1232:	9a e0       	ldi	r25, 0x0A	; 10
    1234:	0e 94 fb 07 	call	0xff6	; 0xff6 <xTaskGenericCreate>
    1238:	81 30       	cpi	r24, 0x01	; 1
    123a:	49 f4       	brne	.+18     	; 0x124e <vTaskStartScheduler+0x46>
    123c:	f8 94       	cli
    123e:	80 93 1f 03 	sts	0x031F, r24	; 0x80031f <xSchedulerRunning>
    1242:	10 92 23 03 	sts	0x0323, r1	; 0x800323 <xTickCount+0x1>
    1246:	10 92 22 03 	sts	0x0322, r1	; 0x800322 <xTickCount>
    124a:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <xPortStartScheduler>
    124e:	0f 91       	pop	r16
    1250:	ff 90       	pop	r15
    1252:	ef 90       	pop	r14
    1254:	df 90       	pop	r13
    1256:	cf 90       	pop	r12
    1258:	bf 90       	pop	r11
    125a:	af 90       	pop	r10
    125c:	08 95       	ret

0000125e <vTaskSuspendAll>:
    125e:	80 91 1e 03 	lds	r24, 0x031E	; 0x80031e <uxSchedulerSuspended>
    1262:	8f 5f       	subi	r24, 0xFF	; 255
    1264:	80 93 1e 03 	sts	0x031E, r24	; 0x80031e <uxSchedulerSuspended>
    1268:	08 95       	ret

0000126a <xTaskGetTickCount>:
    126a:	0f b6       	in	r0, 0x3f	; 63
    126c:	f8 94       	cli
    126e:	0f 92       	push	r0
    1270:	80 91 22 03 	lds	r24, 0x0322	; 0x800322 <xTickCount>
    1274:	90 91 23 03 	lds	r25, 0x0323	; 0x800323 <xTickCount+0x1>
    1278:	0f 90       	pop	r0
    127a:	0f be       	out	0x3f, r0	; 63
    127c:	08 95       	ret

0000127e <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    127e:	0f 93       	push	r16
    1280:	1f 93       	push	r17
    1282:	cf 93       	push	r28
    1284:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1286:	80 91 1e 03 	lds	r24, 0x031E	; 0x80031e <uxSchedulerSuspended>
    128a:	81 11       	cpse	r24, r1
    128c:	b2 c0       	rjmp	.+356    	; 0x13f2 <vTaskIncrementTick+0x174>
	{
		++xTickCount;
    128e:	80 91 22 03 	lds	r24, 0x0322	; 0x800322 <xTickCount>
    1292:	90 91 23 03 	lds	r25, 0x0323	; 0x800323 <xTickCount+0x1>
    1296:	01 96       	adiw	r24, 0x01	; 1
    1298:	90 93 23 03 	sts	0x0323, r25	; 0x800323 <xTickCount+0x1>
    129c:	80 93 22 03 	sts	0x0322, r24	; 0x800322 <xTickCount>
		if( xTickCount == ( portTickType ) 0U )
    12a0:	80 91 22 03 	lds	r24, 0x0322	; 0x800322 <xTickCount>
    12a4:	90 91 23 03 	lds	r25, 0x0323	; 0x800323 <xTickCount+0x1>
    12a8:	89 2b       	or	r24, r25
    12aa:	99 f5       	brne	.+102    	; 0x1312 <vTaskIncrementTick+0x94>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    12ac:	80 91 3a 03 	lds	r24, 0x033A	; 0x80033a <pxDelayedTaskList>
    12b0:	90 91 3b 03 	lds	r25, 0x033B	; 0x80033b <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    12b4:	20 91 38 03 	lds	r18, 0x0338	; 0x800338 <pxOverflowDelayedTaskList>
    12b8:	30 91 39 03 	lds	r19, 0x0339	; 0x800339 <pxOverflowDelayedTaskList+0x1>
    12bc:	30 93 3b 03 	sts	0x033B, r19	; 0x80033b <pxDelayedTaskList+0x1>
    12c0:	20 93 3a 03 	sts	0x033A, r18	; 0x80033a <pxDelayedTaskList>
			pxOverflowDelayedTaskList = pxTemp;
    12c4:	90 93 39 03 	sts	0x0339, r25	; 0x800339 <pxOverflowDelayedTaskList+0x1>
    12c8:	80 93 38 03 	sts	0x0338, r24	; 0x800338 <pxOverflowDelayedTaskList>
			xNumOfOverflows++;
    12cc:	80 91 1b 03 	lds	r24, 0x031B	; 0x80031b <xNumOfOverflows>
    12d0:	8f 5f       	subi	r24, 0xFF	; 255
    12d2:	80 93 1b 03 	sts	0x031B, r24	; 0x80031b <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    12d6:	e0 91 3a 03 	lds	r30, 0x033A	; 0x80033a <pxDelayedTaskList>
    12da:	f0 91 3b 03 	lds	r31, 0x033B	; 0x80033b <pxDelayedTaskList+0x1>
    12de:	80 81       	ld	r24, Z
    12e0:	81 11       	cpse	r24, r1
    12e2:	07 c0       	rjmp	.+14     	; 0x12f2 <vTaskIncrementTick+0x74>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    12e4:	8f ef       	ldi	r24, 0xFF	; 255
    12e6:	9f ef       	ldi	r25, 0xFF	; 255
    12e8:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <xNextTaskUnblockTime+0x1>
    12ec:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <xNextTaskUnblockTime>
    12f0:	10 c0       	rjmp	.+32     	; 0x1312 <vTaskIncrementTick+0x94>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    12f2:	e0 91 3a 03 	lds	r30, 0x033A	; 0x80033a <pxDelayedTaskList>
    12f6:	f0 91 3b 03 	lds	r31, 0x033B	; 0x80033b <pxDelayedTaskList+0x1>
    12fa:	05 80       	ldd	r0, Z+5	; 0x05
    12fc:	f6 81       	ldd	r31, Z+6	; 0x06
    12fe:	e0 2d       	mov	r30, r0
    1300:	06 80       	ldd	r0, Z+6	; 0x06
    1302:	f7 81       	ldd	r31, Z+7	; 0x07
    1304:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1306:	82 81       	ldd	r24, Z+2	; 0x02
    1308:	93 81       	ldd	r25, Z+3	; 0x03
    130a:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <xNextTaskUnblockTime+0x1>
    130e:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <xNextTaskUnblockTime>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1312:	20 91 22 03 	lds	r18, 0x0322	; 0x800322 <xTickCount>
    1316:	30 91 23 03 	lds	r19, 0x0323	; 0x800323 <xTickCount+0x1>
    131a:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <xNextTaskUnblockTime>
    131e:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <xNextTaskUnblockTime+0x1>
    1322:	28 17       	cp	r18, r24
    1324:	39 07       	cpc	r19, r25
    1326:	08 f4       	brcc	.+2      	; 0x132a <vTaskIncrementTick+0xac>
    1328:	69 c0       	rjmp	.+210    	; 0x13fc <vTaskIncrementTick+0x17e>
    132a:	e0 91 3a 03 	lds	r30, 0x033A	; 0x80033a <pxDelayedTaskList>
    132e:	f0 91 3b 03 	lds	r31, 0x033B	; 0x80033b <pxDelayedTaskList+0x1>
    1332:	80 81       	ld	r24, Z
    1334:	88 23       	and	r24, r24
    1336:	99 f0       	breq	.+38     	; 0x135e <vTaskIncrementTick+0xe0>
    1338:	e0 91 3a 03 	lds	r30, 0x033A	; 0x80033a <pxDelayedTaskList>
    133c:	f0 91 3b 03 	lds	r31, 0x033B	; 0x80033b <pxDelayedTaskList+0x1>
    1340:	05 80       	ldd	r0, Z+5	; 0x05
    1342:	f6 81       	ldd	r31, Z+6	; 0x06
    1344:	e0 2d       	mov	r30, r0
    1346:	c6 81       	ldd	r28, Z+6	; 0x06
    1348:	d7 81       	ldd	r29, Z+7	; 0x07
    134a:	8a 81       	ldd	r24, Y+2	; 0x02
    134c:	9b 81       	ldd	r25, Y+3	; 0x03
    134e:	20 91 22 03 	lds	r18, 0x0322	; 0x800322 <xTickCount>
    1352:	30 91 23 03 	lds	r19, 0x0323	; 0x800323 <xTickCount+0x1>
    1356:	28 17       	cp	r18, r24
    1358:	39 07       	cpc	r19, r25
    135a:	f8 f4       	brcc	.+62     	; 0x139a <vTaskIncrementTick+0x11c>
    135c:	19 c0       	rjmp	.+50     	; 0x1390 <vTaskIncrementTick+0x112>
    135e:	8f ef       	ldi	r24, 0xFF	; 255
    1360:	9f ef       	ldi	r25, 0xFF	; 255
    1362:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <xNextTaskUnblockTime+0x1>
    1366:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <xNextTaskUnblockTime>
    136a:	48 c0       	rjmp	.+144    	; 0x13fc <vTaskIncrementTick+0x17e>
    136c:	e0 91 3a 03 	lds	r30, 0x033A	; 0x80033a <pxDelayedTaskList>
    1370:	f0 91 3b 03 	lds	r31, 0x033B	; 0x80033b <pxDelayedTaskList+0x1>
    1374:	05 80       	ldd	r0, Z+5	; 0x05
    1376:	f6 81       	ldd	r31, Z+6	; 0x06
    1378:	e0 2d       	mov	r30, r0
    137a:	c6 81       	ldd	r28, Z+6	; 0x06
    137c:	d7 81       	ldd	r29, Z+7	; 0x07
    137e:	8a 81       	ldd	r24, Y+2	; 0x02
    1380:	9b 81       	ldd	r25, Y+3	; 0x03
    1382:	20 91 22 03 	lds	r18, 0x0322	; 0x800322 <xTickCount>
    1386:	30 91 23 03 	lds	r19, 0x0323	; 0x800323 <xTickCount+0x1>
    138a:	28 17       	cp	r18, r24
    138c:	39 07       	cpc	r19, r25
    138e:	28 f4       	brcc	.+10     	; 0x139a <vTaskIncrementTick+0x11c>
    1390:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <xNextTaskUnblockTime+0x1>
    1394:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <xNextTaskUnblockTime>
    1398:	31 c0       	rjmp	.+98     	; 0x13fc <vTaskIncrementTick+0x17e>
    139a:	8e 01       	movw	r16, r28
    139c:	0e 5f       	subi	r16, 0xFE	; 254
    139e:	1f 4f       	sbci	r17, 0xFF	; 255
    13a0:	c8 01       	movw	r24, r16
    13a2:	0e 94 4a 02 	call	0x494	; 0x494 <vListRemove>
    13a6:	8c 89       	ldd	r24, Y+20	; 0x14
    13a8:	9d 89       	ldd	r25, Y+21	; 0x15
    13aa:	89 2b       	or	r24, r25
    13ac:	21 f0       	breq	.+8      	; 0x13b6 <vTaskIncrementTick+0x138>
    13ae:	ce 01       	movw	r24, r28
    13b0:	0c 96       	adiw	r24, 0x0c	; 12
    13b2:	0e 94 4a 02 	call	0x494	; 0x494 <vListRemove>
    13b6:	8e 89       	ldd	r24, Y+22	; 0x16
    13b8:	90 91 20 03 	lds	r25, 0x0320	; 0x800320 <uxTopReadyPriority>
    13bc:	98 17       	cp	r25, r24
    13be:	10 f4       	brcc	.+4      	; 0x13c4 <vTaskIncrementTick+0x146>
    13c0:	80 93 20 03 	sts	0x0320, r24	; 0x800320 <uxTopReadyPriority>
    13c4:	90 e0       	ldi	r25, 0x00	; 0
    13c6:	9c 01       	movw	r18, r24
    13c8:	22 0f       	add	r18, r18
    13ca:	33 1f       	adc	r19, r19
    13cc:	22 0f       	add	r18, r18
    13ce:	33 1f       	adc	r19, r19
    13d0:	22 0f       	add	r18, r18
    13d2:	33 1f       	adc	r19, r19
    13d4:	82 0f       	add	r24, r18
    13d6:	93 1f       	adc	r25, r19
    13d8:	b8 01       	movw	r22, r16
    13da:	82 5b       	subi	r24, 0xB2	; 178
    13dc:	9c 4f       	sbci	r25, 0xFC	; 252
    13de:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <vListInsertEnd>
    13e2:	e0 91 3a 03 	lds	r30, 0x033A	; 0x80033a <pxDelayedTaskList>
    13e6:	f0 91 3b 03 	lds	r31, 0x033B	; 0x80033b <pxDelayedTaskList+0x1>
    13ea:	80 81       	ld	r24, Z
    13ec:	81 11       	cpse	r24, r1
    13ee:	be cf       	rjmp	.-132    	; 0x136c <vTaskIncrementTick+0xee>
    13f0:	b6 cf       	rjmp	.-148    	; 0x135e <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    13f2:	80 91 1d 03 	lds	r24, 0x031D	; 0x80031d <uxMissedTicks>
    13f6:	8f 5f       	subi	r24, 0xFF	; 255
    13f8:	80 93 1d 03 	sts	0x031D, r24	; 0x80031d <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    13fc:	df 91       	pop	r29
    13fe:	cf 91       	pop	r28
    1400:	1f 91       	pop	r17
    1402:	0f 91       	pop	r16
    1404:	08 95       	ret

00001406 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1406:	cf 92       	push	r12
    1408:	df 92       	push	r13
    140a:	ef 92       	push	r14
    140c:	ff 92       	push	r15
    140e:	0f 93       	push	r16
    1410:	1f 93       	push	r17
    1412:	cf 93       	push	r28
    1414:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1416:	0f b6       	in	r0, 0x3f	; 63
    1418:	f8 94       	cli
    141a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    141c:	80 91 1e 03 	lds	r24, 0x031E	; 0x80031e <uxSchedulerSuspended>
    1420:	81 50       	subi	r24, 0x01	; 1
    1422:	80 93 1e 03 	sts	0x031E, r24	; 0x80031e <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1426:	80 91 1e 03 	lds	r24, 0x031E	; 0x80031e <uxSchedulerSuspended>
    142a:	81 11       	cpse	r24, r1
    142c:	63 c0       	rjmp	.+198    	; 0x14f4 <xTaskResumeAll+0xee>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    142e:	80 91 24 03 	lds	r24, 0x0324	; 0x800324 <uxCurrentNumberOfTasks>
    1432:	81 11       	cpse	r24, r1
    1434:	32 c0       	rjmp	.+100    	; 0x149a <xTaskResumeAll+0x94>
    1436:	61 c0       	rjmp	.+194    	; 0x14fa <xTaskResumeAll+0xf4>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1438:	d7 01       	movw	r26, r14
    143a:	15 96       	adiw	r26, 0x05	; 5
    143c:	ed 91       	ld	r30, X+
    143e:	fc 91       	ld	r31, X
    1440:	16 97       	sbiw	r26, 0x06	; 6
    1442:	c6 81       	ldd	r28, Z+6	; 0x06
    1444:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    1446:	ce 01       	movw	r24, r28
    1448:	0c 96       	adiw	r24, 0x0c	; 12
    144a:	0e 94 4a 02 	call	0x494	; 0x494 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    144e:	8e 01       	movw	r16, r28
    1450:	0e 5f       	subi	r16, 0xFE	; 254
    1452:	1f 4f       	sbci	r17, 0xFF	; 255
    1454:	c8 01       	movw	r24, r16
    1456:	0e 94 4a 02 	call	0x494	; 0x494 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    145a:	8e 89       	ldd	r24, Y+22	; 0x16
    145c:	90 91 20 03 	lds	r25, 0x0320	; 0x800320 <uxTopReadyPriority>
    1460:	98 17       	cp	r25, r24
    1462:	10 f4       	brcc	.+4      	; 0x1468 <xTaskResumeAll+0x62>
    1464:	80 93 20 03 	sts	0x0320, r24	; 0x800320 <uxTopReadyPriority>
    1468:	90 e0       	ldi	r25, 0x00	; 0
    146a:	9c 01       	movw	r18, r24
    146c:	22 0f       	add	r18, r18
    146e:	33 1f       	adc	r19, r19
    1470:	22 0f       	add	r18, r18
    1472:	33 1f       	adc	r19, r19
    1474:	22 0f       	add	r18, r18
    1476:	33 1f       	adc	r19, r19
    1478:	82 0f       	add	r24, r18
    147a:	93 1f       	adc	r25, r19
    147c:	b8 01       	movw	r22, r16
    147e:	82 5b       	subi	r24, 0xB2	; 178
    1480:	9c 4f       	sbci	r25, 0xFC	; 252
    1482:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1486:	e0 91 7b 03 	lds	r30, 0x037B	; 0x80037b <pxCurrentTCB>
    148a:	f0 91 7c 03 	lds	r31, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
    148e:	9e 89       	ldd	r25, Y+22	; 0x16
    1490:	86 89       	ldd	r24, Z+22	; 0x16
    1492:	98 17       	cp	r25, r24
    1494:	58 f0       	brcs	.+22     	; 0x14ac <xTaskResumeAll+0xa6>
					{
						xYieldRequired = pdTRUE;
    1496:	dc 2c       	mov	r13, r12
    1498:	09 c0       	rjmp	.+18     	; 0x14ac <xTaskResumeAll+0xa6>
    149a:	d1 2c       	mov	r13, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    149c:	0f 2e       	mov	r0, r31
    149e:	ff e2       	ldi	r31, 0x2F	; 47
    14a0:	ef 2e       	mov	r14, r31
    14a2:	f3 e0       	ldi	r31, 0x03	; 3
    14a4:	ff 2e       	mov	r15, r31
    14a6:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    14a8:	cc 24       	eor	r12, r12
    14aa:	c3 94       	inc	r12
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    14ac:	f7 01       	movw	r30, r14
    14ae:	80 81       	ld	r24, Z
    14b0:	81 11       	cpse	r24, r1
    14b2:	c2 cf       	rjmp	.-124    	; 0x1438 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    14b4:	80 91 1d 03 	lds	r24, 0x031D	; 0x80031d <uxMissedTicks>
    14b8:	88 23       	and	r24, r24
    14ba:	79 f0       	breq	.+30     	; 0x14da <xTaskResumeAll+0xd4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    14bc:	80 91 1d 03 	lds	r24, 0x031D	; 0x80031d <uxMissedTicks>
    14c0:	88 23       	and	r24, r24
    14c2:	59 f0       	breq	.+22     	; 0x14da <xTaskResumeAll+0xd4>
					{
						vTaskIncrementTick();
    14c4:	0e 94 3f 09 	call	0x127e	; 0x127e <vTaskIncrementTick>
						--uxMissedTicks;
    14c8:	80 91 1d 03 	lds	r24, 0x031D	; 0x80031d <uxMissedTicks>
    14cc:	81 50       	subi	r24, 0x01	; 1
    14ce:	80 93 1d 03 	sts	0x031D, r24	; 0x80031d <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    14d2:	80 91 1d 03 	lds	r24, 0x031D	; 0x80031d <uxMissedTicks>
    14d6:	81 11       	cpse	r24, r1
    14d8:	f5 cf       	rjmp	.-22     	; 0x14c4 <xTaskResumeAll+0xbe>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    14da:	f1 e0       	ldi	r31, 0x01	; 1
    14dc:	df 16       	cp	r13, r31
    14de:	21 f0       	breq	.+8      	; 0x14e8 <xTaskResumeAll+0xe2>
    14e0:	80 91 1c 03 	lds	r24, 0x031C	; 0x80031c <xMissedYield>
    14e4:	81 30       	cpi	r24, 0x01	; 1
    14e6:	41 f4       	brne	.+16     	; 0x14f8 <xTaskResumeAll+0xf2>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    14e8:	10 92 1c 03 	sts	0x031C, r1	; 0x80031c <xMissedYield>
					portYIELD_WITHIN_API();
    14ec:	0e 94 11 03 	call	0x622	; 0x622 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    14f0:	81 e0       	ldi	r24, 0x01	; 1
    14f2:	03 c0       	rjmp	.+6      	; 0x14fa <xTaskResumeAll+0xf4>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    14f4:	80 e0       	ldi	r24, 0x00	; 0
    14f6:	01 c0       	rjmp	.+2      	; 0x14fa <xTaskResumeAll+0xf4>
    14f8:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    14fa:	0f 90       	pop	r0
    14fc:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    14fe:	df 91       	pop	r29
    1500:	cf 91       	pop	r28
    1502:	1f 91       	pop	r17
    1504:	0f 91       	pop	r16
    1506:	ff 90       	pop	r15
    1508:	ef 90       	pop	r14
    150a:	df 90       	pop	r13
    150c:	cf 90       	pop	r12
    150e:	08 95       	ret

00001510 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1510:	0f 93       	push	r16
    1512:	1f 93       	push	r17
    1514:	cf 93       	push	r28
    1516:	df 93       	push	r29
    1518:	8c 01       	movw	r16, r24
    151a:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    151c:	0e 94 2f 09 	call	0x125e	; 0x125e <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1520:	f8 01       	movw	r30, r16
    1522:	80 81       	ld	r24, Z
    1524:	91 81       	ldd	r25, Z+1	; 0x01
    1526:	c8 0f       	add	r28, r24
    1528:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    152a:	20 91 22 03 	lds	r18, 0x0322	; 0x800322 <xTickCount>
    152e:	30 91 23 03 	lds	r19, 0x0323	; 0x800323 <xTickCount+0x1>
    1532:	28 17       	cp	r18, r24
    1534:	39 07       	cpc	r19, r25
    1536:	68 f4       	brcc	.+26     	; 0x1552 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1538:	c8 17       	cp	r28, r24
    153a:	d9 07       	cpc	r29, r25
    153c:	50 f5       	brcc	.+84     	; 0x1592 <vTaskDelayUntil+0x82>
    153e:	80 91 22 03 	lds	r24, 0x0322	; 0x800322 <xTickCount>
    1542:	90 91 23 03 	lds	r25, 0x0323	; 0x800323 <xTickCount+0x1>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1546:	d1 83       	std	Z+1, r29	; 0x01
    1548:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    154a:	8c 17       	cp	r24, r28
    154c:	9d 07       	cpc	r25, r29
    154e:	b0 f4       	brcc	.+44     	; 0x157c <vTaskDelayUntil+0x6c>
    1550:	0b c0       	rjmp	.+22     	; 0x1568 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1552:	c8 17       	cp	r28, r24
    1554:	d9 07       	cpc	r29, r25
    1556:	c8 f0       	brcs	.+50     	; 0x158a <vTaskDelayUntil+0x7a>
    1558:	80 91 22 03 	lds	r24, 0x0322	; 0x800322 <xTickCount>
    155c:	90 91 23 03 	lds	r25, 0x0323	; 0x800323 <xTickCount+0x1>
    1560:	8c 17       	cp	r24, r28
    1562:	9d 07       	cpc	r25, r29
    1564:	90 f0       	brcs	.+36     	; 0x158a <vTaskDelayUntil+0x7a>
    1566:	15 c0       	rjmp	.+42     	; 0x1592 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1568:	80 91 7b 03 	lds	r24, 0x037B	; 0x80037b <pxCurrentTCB>
    156c:	90 91 7c 03 	lds	r25, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
    1570:	02 96       	adiw	r24, 0x02	; 2
    1572:	0e 94 4a 02 	call	0x494	; 0x494 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1576:	ce 01       	movw	r24, r28
    1578:	0e 94 c4 07 	call	0xf88	; 0xf88 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    157c:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1580:	81 11       	cpse	r24, r1
    1582:	0b c0       	rjmp	.+22     	; 0x159a <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    1584:	0e 94 11 03 	call	0x622	; 0x622 <vPortYield>
		}
	}
    1588:	08 c0       	rjmp	.+16     	; 0x159a <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    158a:	f8 01       	movw	r30, r16
    158c:	d1 83       	std	Z+1, r29	; 0x01
    158e:	c0 83       	st	Z, r28
    1590:	eb cf       	rjmp	.-42     	; 0x1568 <vTaskDelayUntil+0x58>
    1592:	f8 01       	movw	r30, r16
    1594:	d1 83       	std	Z+1, r29	; 0x01
    1596:	c0 83       	st	Z, r28
    1598:	f1 cf       	rjmp	.-30     	; 0x157c <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    159a:	df 91       	pop	r29
    159c:	cf 91       	pop	r28
    159e:	1f 91       	pop	r17
    15a0:	0f 91       	pop	r16
    15a2:	08 95       	ret

000015a4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    15a4:	cf 93       	push	r28
    15a6:	df 93       	push	r29
    15a8:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    15aa:	89 2b       	or	r24, r25
    15ac:	b1 f0       	breq	.+44     	; 0x15da <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    15ae:	0e 94 2f 09 	call	0x125e	; 0x125e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    15b2:	80 91 22 03 	lds	r24, 0x0322	; 0x800322 <xTickCount>
    15b6:	90 91 23 03 	lds	r25, 0x0323	; 0x800323 <xTickCount+0x1>
    15ba:	c8 0f       	add	r28, r24
    15bc:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    15be:	80 91 7b 03 	lds	r24, 0x037B	; 0x80037b <pxCurrentTCB>
    15c2:	90 91 7c 03 	lds	r25, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
    15c6:	02 96       	adiw	r24, 0x02	; 2
    15c8:	0e 94 4a 02 	call	0x494	; 0x494 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    15cc:	ce 01       	movw	r24, r28
    15ce:	0e 94 c4 07 	call	0xf88	; 0xf88 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    15d2:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    15d6:	81 11       	cpse	r24, r1
    15d8:	02 c0       	rjmp	.+4      	; 0x15de <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    15da:	0e 94 11 03 	call	0x622	; 0x622 <vPortYield>
		}
	}
    15de:	df 91       	pop	r29
    15e0:	cf 91       	pop	r28
    15e2:	08 95       	ret

000015e4 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    15e4:	06 e2       	ldi	r16, 0x26	; 38
    15e6:	13 e0       	ldi	r17, 0x03	; 3
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    15e8:	80 91 25 03 	lds	r24, 0x0325	; 0x800325 <uxTasksDeleted>
    15ec:	88 23       	and	r24, r24
    15ee:	49 f1       	breq	.+82     	; 0x1642 <prvIdleTask+0x5e>
		{
			vTaskSuspendAll();
    15f0:	0e 94 2f 09 	call	0x125e	; 0x125e <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    15f4:	d8 01       	movw	r26, r16
    15f6:	cc 91       	ld	r28, X
			xTaskResumeAll();
    15f8:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    15fc:	cc 23       	and	r28, r28
    15fe:	09 f1       	breq	.+66     	; 0x1642 <prvIdleTask+0x5e>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1600:	0f b6       	in	r0, 0x3f	; 63
    1602:	f8 94       	cli
    1604:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    1606:	d8 01       	movw	r26, r16
    1608:	15 96       	adiw	r26, 0x05	; 5
    160a:	ed 91       	ld	r30, X+
    160c:	fc 91       	ld	r31, X
    160e:	16 97       	sbiw	r26, 0x06	; 6
    1610:	c6 81       	ldd	r28, Z+6	; 0x06
    1612:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1614:	ce 01       	movw	r24, r28
    1616:	02 96       	adiw	r24, 0x02	; 2
    1618:	0e 94 4a 02 	call	0x494	; 0x494 <vListRemove>
					--uxCurrentNumberOfTasks;
    161c:	80 91 24 03 	lds	r24, 0x0324	; 0x800324 <uxCurrentNumberOfTasks>
    1620:	81 50       	subi	r24, 0x01	; 1
    1622:	80 93 24 03 	sts	0x0324, r24	; 0x800324 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    1626:	80 91 25 03 	lds	r24, 0x0325	; 0x800325 <uxTasksDeleted>
    162a:	81 50       	subi	r24, 0x01	; 1
    162c:	80 93 25 03 	sts	0x0325, r24	; 0x800325 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    1630:	0f 90       	pop	r0
    1632:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1634:	8f 89       	ldd	r24, Y+23	; 0x17
    1636:	98 8d       	ldd	r25, Y+24	; 0x18
    1638:	0e 94 cd 00 	call	0x19a	; 0x19a <vPortFree>
		vPortFree( pxTCB );
    163c:	ce 01       	movw	r24, r28
    163e:	0e 94 cd 00 	call	0x19a	; 0x19a <vPortFree>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    1642:	0e 94 11 03 	call	0x622	; 0x622 <vPortYield>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
    1646:	d0 cf       	rjmp	.-96     	; 0x15e8 <prvIdleTask+0x4>

00001648 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1648:	80 91 1e 03 	lds	r24, 0x031E	; 0x80031e <uxSchedulerSuspended>
    164c:	81 11       	cpse	r24, r1
    164e:	13 c0       	rjmp	.+38     	; 0x1676 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1650:	80 91 20 03 	lds	r24, 0x0320	; 0x800320 <uxTopReadyPriority>
    1654:	90 e0       	ldi	r25, 0x00	; 0
    1656:	fc 01       	movw	r30, r24
    1658:	ee 0f       	add	r30, r30
    165a:	ff 1f       	adc	r31, r31
    165c:	ee 0f       	add	r30, r30
    165e:	ff 1f       	adc	r31, r31
    1660:	ee 0f       	add	r30, r30
    1662:	ff 1f       	adc	r31, r31
    1664:	8e 0f       	add	r24, r30
    1666:	9f 1f       	adc	r25, r31
    1668:	fc 01       	movw	r30, r24
    166a:	e2 5b       	subi	r30, 0xB2	; 178
    166c:	fc 4f       	sbci	r31, 0xFC	; 252
    166e:	80 81       	ld	r24, Z
    1670:	88 23       	and	r24, r24
    1672:	29 f0       	breq	.+10     	; 0x167e <vTaskSwitchContext+0x36>
    1674:	1b c0       	rjmp	.+54     	; 0x16ac <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1676:	81 e0       	ldi	r24, 0x01	; 1
    1678:	80 93 1c 03 	sts	0x031C, r24	; 0x80031c <xMissedYield>
    167c:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    167e:	80 91 20 03 	lds	r24, 0x0320	; 0x800320 <uxTopReadyPriority>
    1682:	81 50       	subi	r24, 0x01	; 1
    1684:	80 93 20 03 	sts	0x0320, r24	; 0x800320 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1688:	80 91 20 03 	lds	r24, 0x0320	; 0x800320 <uxTopReadyPriority>
    168c:	90 e0       	ldi	r25, 0x00	; 0
    168e:	fc 01       	movw	r30, r24
    1690:	ee 0f       	add	r30, r30
    1692:	ff 1f       	adc	r31, r31
    1694:	ee 0f       	add	r30, r30
    1696:	ff 1f       	adc	r31, r31
    1698:	ee 0f       	add	r30, r30
    169a:	ff 1f       	adc	r31, r31
    169c:	8e 0f       	add	r24, r30
    169e:	9f 1f       	adc	r25, r31
    16a0:	fc 01       	movw	r30, r24
    16a2:	e2 5b       	subi	r30, 0xB2	; 178
    16a4:	fc 4f       	sbci	r31, 0xFC	; 252
    16a6:	80 81       	ld	r24, Z
    16a8:	88 23       	and	r24, r24
    16aa:	49 f3       	breq	.-46     	; 0x167e <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    16ac:	80 91 20 03 	lds	r24, 0x0320	; 0x800320 <uxTopReadyPriority>
    16b0:	90 e0       	ldi	r25, 0x00	; 0
    16b2:	9c 01       	movw	r18, r24
    16b4:	22 0f       	add	r18, r18
    16b6:	33 1f       	adc	r19, r19
    16b8:	22 0f       	add	r18, r18
    16ba:	33 1f       	adc	r19, r19
    16bc:	22 0f       	add	r18, r18
    16be:	33 1f       	adc	r19, r19
    16c0:	28 0f       	add	r18, r24
    16c2:	39 1f       	adc	r19, r25
    16c4:	d9 01       	movw	r26, r18
    16c6:	a2 5b       	subi	r26, 0xB2	; 178
    16c8:	bc 4f       	sbci	r27, 0xFC	; 252
    16ca:	11 96       	adiw	r26, 0x01	; 1
    16cc:	ed 91       	ld	r30, X+
    16ce:	fc 91       	ld	r31, X
    16d0:	12 97       	sbiw	r26, 0x02	; 2
    16d2:	02 80       	ldd	r0, Z+2	; 0x02
    16d4:	f3 81       	ldd	r31, Z+3	; 0x03
    16d6:	e0 2d       	mov	r30, r0
    16d8:	12 96       	adiw	r26, 0x02	; 2
    16da:	fc 93       	st	X, r31
    16dc:	ee 93       	st	-X, r30
    16de:	11 97       	sbiw	r26, 0x01	; 1
    16e0:	2f 5a       	subi	r18, 0xAF	; 175
    16e2:	3c 4f       	sbci	r19, 0xFC	; 252
    16e4:	e2 17       	cp	r30, r18
    16e6:	f3 07       	cpc	r31, r19
    16e8:	29 f4       	brne	.+10     	; 0x16f4 <vTaskSwitchContext+0xac>
    16ea:	22 81       	ldd	r18, Z+2	; 0x02
    16ec:	33 81       	ldd	r19, Z+3	; 0x03
    16ee:	fd 01       	movw	r30, r26
    16f0:	32 83       	std	Z+2, r19	; 0x02
    16f2:	21 83       	std	Z+1, r18	; 0x01
    16f4:	fc 01       	movw	r30, r24
    16f6:	ee 0f       	add	r30, r30
    16f8:	ff 1f       	adc	r31, r31
    16fa:	ee 0f       	add	r30, r30
    16fc:	ff 1f       	adc	r31, r31
    16fe:	ee 0f       	add	r30, r30
    1700:	ff 1f       	adc	r31, r31
    1702:	8e 0f       	add	r24, r30
    1704:	9f 1f       	adc	r25, r31
    1706:	fc 01       	movw	r30, r24
    1708:	e2 5b       	subi	r30, 0xB2	; 178
    170a:	fc 4f       	sbci	r31, 0xFC	; 252
    170c:	01 80       	ldd	r0, Z+1	; 0x01
    170e:	f2 81       	ldd	r31, Z+2	; 0x02
    1710:	e0 2d       	mov	r30, r0
    1712:	86 81       	ldd	r24, Z+6	; 0x06
    1714:	97 81       	ldd	r25, Z+7	; 0x07
    1716:	90 93 7c 03 	sts	0x037C, r25	; 0x80037c <pxCurrentTCB+0x1>
    171a:	80 93 7b 03 	sts	0x037B, r24	; 0x80037b <pxCurrentTCB>
    171e:	08 95       	ret

00001720 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1720:	cf 93       	push	r28
    1722:	df 93       	push	r29
    1724:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1726:	60 91 7b 03 	lds	r22, 0x037B	; 0x80037b <pxCurrentTCB>
    172a:	70 91 7c 03 	lds	r23, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
    172e:	64 5f       	subi	r22, 0xF4	; 244
    1730:	7f 4f       	sbci	r23, 0xFF	; 255
    1732:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1736:	80 91 7b 03 	lds	r24, 0x037B	; 0x80037b <pxCurrentTCB>
    173a:	90 91 7c 03 	lds	r25, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
    173e:	02 96       	adiw	r24, 0x02	; 2
    1740:	0e 94 4a 02 	call	0x494	; 0x494 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1744:	80 91 22 03 	lds	r24, 0x0322	; 0x800322 <xTickCount>
    1748:	90 91 23 03 	lds	r25, 0x0323	; 0x800323 <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    174c:	8c 0f       	add	r24, r28
    174e:	9d 1f       	adc	r25, r29
    1750:	0e 94 c4 07 	call	0xf88	; 0xf88 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    1754:	df 91       	pop	r29
    1756:	cf 91       	pop	r28
    1758:	08 95       	ret

0000175a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    175a:	0f 93       	push	r16
    175c:	1f 93       	push	r17
    175e:	cf 93       	push	r28
    1760:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1762:	dc 01       	movw	r26, r24
    1764:	15 96       	adiw	r26, 0x05	; 5
    1766:	ed 91       	ld	r30, X+
    1768:	fc 91       	ld	r31, X
    176a:	16 97       	sbiw	r26, 0x06	; 6
    176c:	c6 81       	ldd	r28, Z+6	; 0x06
    176e:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1770:	8e 01       	movw	r16, r28
    1772:	04 5f       	subi	r16, 0xF4	; 244
    1774:	1f 4f       	sbci	r17, 0xFF	; 255
    1776:	c8 01       	movw	r24, r16
    1778:	0e 94 4a 02 	call	0x494	; 0x494 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    177c:	80 91 1e 03 	lds	r24, 0x031E	; 0x80031e <uxSchedulerSuspended>
    1780:	81 11       	cpse	r24, r1
    1782:	1c c0       	rjmp	.+56     	; 0x17bc <xTaskRemoveFromEventList+0x62>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1784:	0a 50       	subi	r16, 0x0A	; 10
    1786:	11 09       	sbc	r17, r1
    1788:	c8 01       	movw	r24, r16
    178a:	0e 94 4a 02 	call	0x494	; 0x494 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    178e:	8e 89       	ldd	r24, Y+22	; 0x16
    1790:	90 91 20 03 	lds	r25, 0x0320	; 0x800320 <uxTopReadyPriority>
    1794:	98 17       	cp	r25, r24
    1796:	10 f4       	brcc	.+4      	; 0x179c <xTaskRemoveFromEventList+0x42>
    1798:	80 93 20 03 	sts	0x0320, r24	; 0x800320 <uxTopReadyPriority>
    179c:	90 e0       	ldi	r25, 0x00	; 0
    179e:	9c 01       	movw	r18, r24
    17a0:	22 0f       	add	r18, r18
    17a2:	33 1f       	adc	r19, r19
    17a4:	22 0f       	add	r18, r18
    17a6:	33 1f       	adc	r19, r19
    17a8:	22 0f       	add	r18, r18
    17aa:	33 1f       	adc	r19, r19
    17ac:	82 0f       	add	r24, r18
    17ae:	93 1f       	adc	r25, r19
    17b0:	b8 01       	movw	r22, r16
    17b2:	82 5b       	subi	r24, 0xB2	; 178
    17b4:	9c 4f       	sbci	r25, 0xFC	; 252
    17b6:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <vListInsertEnd>
    17ba:	05 c0       	rjmp	.+10     	; 0x17c6 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    17bc:	b8 01       	movw	r22, r16
    17be:	8f e2       	ldi	r24, 0x2F	; 47
    17c0:	93 e0       	ldi	r25, 0x03	; 3
    17c2:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    17c6:	e0 91 7b 03 	lds	r30, 0x037B	; 0x80037b <pxCurrentTCB>
    17ca:	f0 91 7c 03 	lds	r31, 0x037C	; 0x80037c <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    17ce:	81 e0       	ldi	r24, 0x01	; 1
    17d0:	2e 89       	ldd	r18, Y+22	; 0x16
    17d2:	96 89       	ldd	r25, Z+22	; 0x16
    17d4:	29 17       	cp	r18, r25
    17d6:	08 f4       	brcc	.+2      	; 0x17da <xTaskRemoveFromEventList+0x80>
    17d8:	80 e0       	ldi	r24, 0x00	; 0
}
    17da:	df 91       	pop	r29
    17dc:	cf 91       	pop	r28
    17de:	1f 91       	pop	r17
    17e0:	0f 91       	pop	r16
    17e2:	08 95       	ret

000017e4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    17e4:	20 91 1b 03 	lds	r18, 0x031B	; 0x80031b <xNumOfOverflows>
    17e8:	fc 01       	movw	r30, r24
    17ea:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    17ec:	20 91 22 03 	lds	r18, 0x0322	; 0x800322 <xTickCount>
    17f0:	30 91 23 03 	lds	r19, 0x0323	; 0x800323 <xTickCount+0x1>
    17f4:	32 83       	std	Z+2, r19	; 0x02
    17f6:	21 83       	std	Z+1, r18	; 0x01
    17f8:	08 95       	ret

000017fa <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    17fa:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    17fc:	0f b6       	in	r0, 0x3f	; 63
    17fe:	f8 94       	cli
    1800:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1802:	80 91 1b 03 	lds	r24, 0x031B	; 0x80031b <xNumOfOverflows>
    1806:	90 81       	ld	r25, Z
    1808:	98 17       	cp	r25, r24
    180a:	49 f0       	breq	.+18     	; 0x181e <xTaskCheckForTimeOut+0x24>
    180c:	80 91 22 03 	lds	r24, 0x0322	; 0x800322 <xTickCount>
    1810:	90 91 23 03 	lds	r25, 0x0323	; 0x800323 <xTickCount+0x1>
    1814:	21 81       	ldd	r18, Z+1	; 0x01
    1816:	32 81       	ldd	r19, Z+2	; 0x02
    1818:	82 17       	cp	r24, r18
    181a:	93 07       	cpc	r25, r19
    181c:	f8 f4       	brcc	.+62     	; 0x185c <xTaskCheckForTimeOut+0x62>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    181e:	80 91 22 03 	lds	r24, 0x0322	; 0x800322 <xTickCount>
    1822:	90 91 23 03 	lds	r25, 0x0323	; 0x800323 <xTickCount+0x1>
    1826:	41 81       	ldd	r20, Z+1	; 0x01
    1828:	52 81       	ldd	r21, Z+2	; 0x02
    182a:	db 01       	movw	r26, r22
    182c:	2d 91       	ld	r18, X+
    182e:	3c 91       	ld	r19, X
    1830:	11 97       	sbiw	r26, 0x01	; 1
    1832:	84 1b       	sub	r24, r20
    1834:	95 0b       	sbc	r25, r21
    1836:	82 17       	cp	r24, r18
    1838:	93 07       	cpc	r25, r19
    183a:	90 f4       	brcc	.+36     	; 0x1860 <xTaskCheckForTimeOut+0x66>
    183c:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    183e:	e0 91 22 03 	lds	r30, 0x0322	; 0x800322 <xTickCount>
    1842:	f0 91 23 03 	lds	r31, 0x0323	; 0x800323 <xTickCount+0x1>
    1846:	bf 01       	movw	r22, r30
    1848:	64 1b       	sub	r22, r20
    184a:	75 0b       	sbc	r23, r21
    184c:	26 1b       	sub	r18, r22
    184e:	37 0b       	sbc	r19, r23
    1850:	2d 93       	st	X+, r18
    1852:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1854:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1858:	80 e0       	ldi	r24, 0x00	; 0
    185a:	03 c0       	rjmp	.+6      	; 0x1862 <xTaskCheckForTimeOut+0x68>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    185c:	81 e0       	ldi	r24, 0x01	; 1
    185e:	01 c0       	rjmp	.+2      	; 0x1862 <xTaskCheckForTimeOut+0x68>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1860:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1862:	0f 90       	pop	r0
    1864:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1866:	08 95       	ret

00001868 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1868:	81 e0       	ldi	r24, 0x01	; 1
    186a:	80 93 1c 03 	sts	0x031C, r24	; 0x80031c <xMissedYield>
    186e:	08 95       	ret

00001870 <__divmodhi4>:
    1870:	97 fb       	bst	r25, 7
    1872:	07 2e       	mov	r0, r23
    1874:	16 f4       	brtc	.+4      	; 0x187a <__divmodhi4+0xa>
    1876:	00 94       	com	r0
    1878:	07 d0       	rcall	.+14     	; 0x1888 <__divmodhi4_neg1>
    187a:	77 fd       	sbrc	r23, 7
    187c:	09 d0       	rcall	.+18     	; 0x1890 <__divmodhi4_neg2>
    187e:	0e 94 52 0c 	call	0x18a4	; 0x18a4 <__udivmodhi4>
    1882:	07 fc       	sbrc	r0, 7
    1884:	05 d0       	rcall	.+10     	; 0x1890 <__divmodhi4_neg2>
    1886:	3e f4       	brtc	.+14     	; 0x1896 <__divmodhi4_exit>

00001888 <__divmodhi4_neg1>:
    1888:	90 95       	com	r25
    188a:	81 95       	neg	r24
    188c:	9f 4f       	sbci	r25, 0xFF	; 255
    188e:	08 95       	ret

00001890 <__divmodhi4_neg2>:
    1890:	70 95       	com	r23
    1892:	61 95       	neg	r22
    1894:	7f 4f       	sbci	r23, 0xFF	; 255

00001896 <__divmodhi4_exit>:
    1896:	08 95       	ret

00001898 <__tablejump2__>:
    1898:	ee 0f       	add	r30, r30
    189a:	ff 1f       	adc	r31, r31
    189c:	05 90       	lpm	r0, Z+
    189e:	f4 91       	lpm	r31, Z
    18a0:	e0 2d       	mov	r30, r0
    18a2:	09 94       	ijmp

000018a4 <__udivmodhi4>:
    18a4:	aa 1b       	sub	r26, r26
    18a6:	bb 1b       	sub	r27, r27
    18a8:	51 e1       	ldi	r21, 0x11	; 17
    18aa:	07 c0       	rjmp	.+14     	; 0x18ba <__udivmodhi4_ep>

000018ac <__udivmodhi4_loop>:
    18ac:	aa 1f       	adc	r26, r26
    18ae:	bb 1f       	adc	r27, r27
    18b0:	a6 17       	cp	r26, r22
    18b2:	b7 07       	cpc	r27, r23
    18b4:	10 f0       	brcs	.+4      	; 0x18ba <__udivmodhi4_ep>
    18b6:	a6 1b       	sub	r26, r22
    18b8:	b7 0b       	sbc	r27, r23

000018ba <__udivmodhi4_ep>:
    18ba:	88 1f       	adc	r24, r24
    18bc:	99 1f       	adc	r25, r25
    18be:	5a 95       	dec	r21
    18c0:	a9 f7       	brne	.-22     	; 0x18ac <__udivmodhi4_loop>
    18c2:	80 95       	com	r24
    18c4:	90 95       	com	r25
    18c6:	bc 01       	movw	r22, r24
    18c8:	cd 01       	movw	r24, r26
    18ca:	08 95       	ret

000018cc <atoi>:
    18cc:	fc 01       	movw	r30, r24
    18ce:	88 27       	eor	r24, r24
    18d0:	99 27       	eor	r25, r25
    18d2:	e8 94       	clt
    18d4:	21 91       	ld	r18, Z+
    18d6:	20 32       	cpi	r18, 0x20	; 32
    18d8:	e9 f3       	breq	.-6      	; 0x18d4 <atoi+0x8>
    18da:	29 30       	cpi	r18, 0x09	; 9
    18dc:	10 f0       	brcs	.+4      	; 0x18e2 <atoi+0x16>
    18de:	2e 30       	cpi	r18, 0x0E	; 14
    18e0:	c8 f3       	brcs	.-14     	; 0x18d4 <atoi+0x8>
    18e2:	2b 32       	cpi	r18, 0x2B	; 43
    18e4:	41 f0       	breq	.+16     	; 0x18f6 <atoi+0x2a>
    18e6:	2d 32       	cpi	r18, 0x2D	; 45
    18e8:	39 f4       	brne	.+14     	; 0x18f8 <atoi+0x2c>
    18ea:	68 94       	set
    18ec:	04 c0       	rjmp	.+8      	; 0x18f6 <atoi+0x2a>
    18ee:	0e 94 a3 0c 	call	0x1946	; 0x1946 <__mulhi_const_10>
    18f2:	82 0f       	add	r24, r18
    18f4:	91 1d       	adc	r25, r1
    18f6:	21 91       	ld	r18, Z+
    18f8:	20 53       	subi	r18, 0x30	; 48
    18fa:	2a 30       	cpi	r18, 0x0A	; 10
    18fc:	c0 f3       	brcs	.-16     	; 0x18ee <atoi+0x22>
    18fe:	1e f4       	brtc	.+6      	; 0x1906 <atoi+0x3a>
    1900:	90 95       	com	r25
    1902:	81 95       	neg	r24
    1904:	9f 4f       	sbci	r25, 0xFF	; 255
    1906:	08 95       	ret

00001908 <memcpy>:
    1908:	fb 01       	movw	r30, r22
    190a:	dc 01       	movw	r26, r24
    190c:	02 c0       	rjmp	.+4      	; 0x1912 <memcpy+0xa>
    190e:	01 90       	ld	r0, Z+
    1910:	0d 92       	st	X+, r0
    1912:	41 50       	subi	r20, 0x01	; 1
    1914:	50 40       	sbci	r21, 0x00	; 0
    1916:	d8 f7       	brcc	.-10     	; 0x190e <memcpy+0x6>
    1918:	08 95       	ret

0000191a <memset>:
    191a:	dc 01       	movw	r26, r24
    191c:	01 c0       	rjmp	.+2      	; 0x1920 <memset+0x6>
    191e:	6d 93       	st	X+, r22
    1920:	41 50       	subi	r20, 0x01	; 1
    1922:	50 40       	sbci	r21, 0x00	; 0
    1924:	e0 f7       	brcc	.-8      	; 0x191e <memset+0x4>
    1926:	08 95       	ret

00001928 <strncpy>:
    1928:	fb 01       	movw	r30, r22
    192a:	dc 01       	movw	r26, r24
    192c:	41 50       	subi	r20, 0x01	; 1
    192e:	50 40       	sbci	r21, 0x00	; 0
    1930:	48 f0       	brcs	.+18     	; 0x1944 <strncpy+0x1c>
    1932:	01 90       	ld	r0, Z+
    1934:	0d 92       	st	X+, r0
    1936:	00 20       	and	r0, r0
    1938:	c9 f7       	brne	.-14     	; 0x192c <strncpy+0x4>
    193a:	01 c0       	rjmp	.+2      	; 0x193e <strncpy+0x16>
    193c:	1d 92       	st	X+, r1
    193e:	41 50       	subi	r20, 0x01	; 1
    1940:	50 40       	sbci	r21, 0x00	; 0
    1942:	e0 f7       	brcc	.-8      	; 0x193c <strncpy+0x14>
    1944:	08 95       	ret

00001946 <__mulhi_const_10>:
    1946:	7a e0       	ldi	r23, 0x0A	; 10
    1948:	97 9f       	mul	r25, r23
    194a:	90 2d       	mov	r25, r0
    194c:	87 9f       	mul	r24, r23
    194e:	80 2d       	mov	r24, r0
    1950:	91 0d       	add	r25, r1
    1952:	11 24       	eor	r1, r1
    1954:	08 95       	ret

00001956 <_exit>:
    1956:	f8 94       	cli

00001958 <__stop_program>:
    1958:	ff cf       	rjmp	.-2      	; 0x1958 <__stop_program>
